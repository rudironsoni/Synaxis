// <copyright file="StreamingController.cs" company="Synaxis">
// Copyright (c) Synaxis. All rights reserved.
// </copyright>

namespace Synaxis.Server.Controllers
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text;
    using System.Text.Json;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Extensions.Logging;

    /// <summary>
    /// Controller for streaming inference responses using Server-Sent Events (SSE).
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class StreamingController : ControllerBase
    {
        private readonly ILogger<StreamingController> _logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="StreamingController"/> class.
        /// </summary>
        /// <param name="logger">The logger instance.</param>
        public StreamingController(ILogger<StreamingController> logger)
        {
            ArgumentNullException.ThrowIfNull(logger);
            this._logger = logger;
        }

        /// <summary>
        /// Streams inference responses using Server-Sent Events (SSE).
        /// </summary>
        /// <param name="request">The streaming request.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A stream of SSE events.</returns>
        [HttpPost("chat")]
        public async Task StreamChatAsync(
            [FromBody] StreamingChatRequest request,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(request);
            this._logger.LogInformation(
                "Starting streaming chat for conversation {ConversationId}",
                request.ConversationId);

            // Set SSE headers
            this.Response.ContentType = "text/event-stream";
            this.Response.Headers.Append("Cache-Control", "no-cache");
            this.Response.Headers.Append("Connection", "keep-alive");
            this.Response.Headers.Append("X-Accel-Buffering", "no");

            try
            {
                // Simulate streaming responses
                await foreach (var chunk in this.GenerateStreamChunksAsync(cancellationToken).ConfigureAwait(false))
                {
                    var sseData = FormatSseEvent(chunk);
                    await this.Response.WriteAsync(sseData, cancellationToken).ConfigureAwait(false);
                    await this.Response.Body.FlushAsync(cancellationToken).ConfigureAwait(false);
                }

                // Send done event
                var doneEvent = FormatSseEvent(new StreamChunk { Type = "done", Content = string.Empty });
                await this.Response.WriteAsync(doneEvent, cancellationToken).ConfigureAwait(false);
                await this.Response.Body.FlushAsync(cancellationToken).ConfigureAwait(false);

                this._logger.LogInformation(
                    "Completed streaming chat for conversation {ConversationId}",
                    request.ConversationId);
            }
            catch (OperationCanceledException)
            {
                // Operation was cancelled, no need to log
            }
            catch (Exception ex)
            {
                this._logger.LogError(
                    ex,
                    "Error during streaming chat for conversation {ConversationId}",
                    request.ConversationId);

                // Send error event
                var errorEvent = FormatSseEvent(new StreamChunk
                {
                    Type = "error",
                    Content = $"Error: {ex.Message}",
                });
                await this.Response.WriteAsync(errorEvent, cancellationToken).ConfigureAwait(false);
                await this.Response.Body.FlushAsync(cancellationToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Generates stream chunks for the given request.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>An async enumerable of stream chunks.</returns>
        private async IAsyncEnumerable<StreamChunk> GenerateStreamChunksAsync(
            [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            // Simulate generating text chunks
            var responseText = "This is a simulated streaming response from the Synaxis inference engine. ";
            responseText += "In a real implementation, this would be generated by an AI model. ";
            responseText += "The streaming infrastructure allows for real-time delivery of partial results, ";
            responseText += "providing a better user experience for long-running inference tasks.";

            var words = responseText.Split(' ');
            var currentChunk = new StringBuilder();

            for (int i = 0; i < words.Length; i++)
            {
                cancellationToken.ThrowIfCancellationRequested();

                currentChunk.Append(words[i]).Append(' ');

                // Send chunk every few words
                if ((i + 1) % 3 == 0 || i == words.Length - 1)
                {
                    yield return new StreamChunk
                    {
                        Type = "chunk",
                        Content = currentChunk.ToString().Trim(),
                        Index = i,
                        IsFinal = i == words.Length - 1,
                    };

                    currentChunk.Clear();

                    // Simulate processing delay
                    await Task.Delay(50, cancellationToken).ConfigureAwait(false);
                }
            }
        }

        /// <summary>
        /// Formats a stream chunk as an SSE event.
        /// </summary>
        /// <param name="chunk">The stream chunk.</param>
        /// <returns>The formatted SSE event string.</returns>
        private static string FormatSseEvent(StreamChunk chunk)
        {
            var json = JsonSerializer.Serialize(chunk);
            return $"data: {json}\n\n";
        }

        /// <summary>
        /// Represents a streaming chat request.
        /// </summary>
        public class StreamingChatRequest
        {
            /// <summary>
            /// Gets or sets the conversation ID.
            /// </summary>
            [System.Text.Json.Serialization.JsonRequired]
            public Guid ConversationId { get; set; }

            /// <summary>
            /// Gets or sets the user message.
            /// </summary>
            public string Message { get; set; } = string.Empty;

            /// <summary>
            /// Gets or sets the model to use.
            /// </summary>
            public string Model { get; set; }

            /// <summary>
            /// Gets or sets additional parameters.
            /// </summary>
            public IDictionary<string, object> Parameters { get; set; }
        }

        /// <summary>
        /// Represents a stream chunk.
        /// </summary>
        public class StreamChunk
        {
            /// <summary>
            /// Gets or sets the chunk type (chunk, done, error).
            /// </summary>
            public string Type { get; set; } = "chunk";

            /// <summary>
            /// Gets or sets the chunk content.
            /// </summary>
            public string Content { get; set; } = string.Empty;

            /// <summary>
            /// Gets or sets the chunk index.
            /// </summary>
            public int Index { get; set; }

            /// <summary>
            /// Gets or sets a value indicating whether this is the final chunk.
            /// </summary>
            public bool IsFinal { get; set; }

            /// <summary>
            /// Gets or sets the timestamp.
            /// </summary>
            public long Timestamp { get; set; } = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        }
    }
}
