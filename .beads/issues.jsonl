{"id":"Synaxis-0hr","title":"Create Comprehensive Test Suite for Synaxis.Contracts","description":"Objective: Create unit test project for Synaxis.Contracts with comprehensive coverage of message types, serialization, immutability, and contract validation. Context: Contracts are data shapes that will be serialized/deserialized across process boundaries (HTTP, gRPC, etc.), so testing must verify serialization compatibility, immutability guarantees, and record semantics. Test Categories: (1) Construction Tests - Verify records can be constructed, Verify required properties enforced, Verify optional properties work with init, Verify object initializer syntax works. (2) Immutability Tests - Verify records are immutable after construction, Verify with-expression creates new instance, Verify init-only properties cannot be set after construction. (3) Serialization Tests - Verify JSON serialization works (System.Text.Json), Verify protobuf compatibility (if using protobuf-net), Verify records serialize/deserialize correctly, Verify null handling in serialization. (4) Equality Tests - Verify records have value equality, Verify equality ignores reference identity, Verify GetHashCode is consistent. Directory Structure: tests/Synaxis.Contracts.Tests/ containing Messages/ChatMessageTests.cs (Can_Be_Constructed, Is_Immutable, Has_Value_Equality, Serializes_To_Json), Messages/ChatResponseTests.cs, SerializationTests.cs (All_Messages_Serialize_To_Json, All_Messages_Deserialize_From_Json, Null_Handling_Works), ImmutabilityTests.cs (Records_Are_Immutable, With_Expression_Creates_New_Instance). Test Examples: [Fact] public void ChatMessage_Can_Be_Constructed() { var message = new ChatMessage('user', 'Hello'); Assert.Equal('user', message.Role); Assert.Equal('Hello', message.Content); } [Fact] public void ChatMessage_Is_Immutable() { var message = new ChatMessage('user', 'Hello'); // Should not compile: message.Role = 'assistant'; }. Project File: Tests/Synaxis.Contracts.Tests.csproj references Synaxis.Contracts, uses xUnit, FluentAssertions, System.Text.Json for serialization tests. Coverage Target: \u003e80% line coverage, 100% of public message types tested. Acceptance Criteria: All tests pass, \u003e80% code coverage, all message types proven serializable, immutability verified, equality contracts verified.","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:14.425081509+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:06:14.425081509+01:00"}
{"id":"Synaxis-33p","title":"System Adapters - SignalR, Microsoft.Agents, and MCP Integration","description":"Implements adapters for system-specific integrations beyond basic transports. These are higher-level integrations that may use transports internally but provide specialized functionality. SignalR for real-time .NET applications, Microsoft.Agents for agent orchestration, and MCP for Model Context Protocol support. Scope: (1) Synaxis.Adapters.SignalR - Real-time hubs for streaming, Connection management, Groups for multi-user scenarios. (2) Synaxis.Adapters.Agents - Microsoft.Agents SDK integration, ActivityHandler implementation, Agent orchestration, Tool calling. (3) Synaxis.Adapters.Mcp - Model Context Protocol implementation, Tool definitions, Multiple transport support (stdio, HTTP, SSE). Key Design: All adapters use ICommandExecutor/IStreamExecutor from Foundation, Provide specialized APIs for their ecosystems, Explicit registration required. Dependencies: Epic 1 (Foundation), Epic 2 (Core Implementation). Success Criteria: SignalR hubs support streaming chat, Agents adapter handles Bot Framework activities, MCP adapter exposes tools via protocol, Each adapter has explicit DI registration (AddSynaxisAdapter*), Integration tests for each adapter. Risks: SignalR and Agents have different streaming models (mitigation: abstraction layer handles differences), MCP protocol is evolving (mitigation: follow spec closely, plan for versioning), Adapter complexity grows quickly (mitigation: keep adapters thin, delegate to core).","status":"open","priority":2,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:46.837836493+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:04:46.837836493+01:00"}
{"id":"Synaxis-3sl","title":"Create Synaxis.Abstractions Project - Zero-Dependency Foundation Interfaces","description":"Objective: Create the foundational NuGet package that defines all interfaces and abstractions for the Synaxis SDK with zero external dependencies, targeting .NET Standard 2.1 for maximum compatibility. Context: This is the most critical package in the entire ecosystem - it defines contracts that transports implement (ICommandExecutor, IStreamExecutor), providers implement (IChatProvider, IEmbeddingProvider, etc.), application code consumes (ICommand{T}, IStreamRequest{T}), and external developers extend (custom providers, custom behaviors). Breaking changes here require major version bumps and force all consumers to update. Architectural Decisions: (1) Use Marker Interfaces (Empty Interfaces) - Choice: public interface ICommand{out TResponse} { } (empty). Rationale: Marker interfaces provide type safety without imposing constraints, allow type system to enforce only command types passed to executors, keep interface minimal and extensible. Alternative Considered: Base classes with virtual methods. Rejected Because: Base classes impose inheritance hierarchy, limit flexibility, create versioning challenges. (2) Generic Type Parameters for Command/Response Types - Choice: ICommand{TResponse} with covariant out parameter. Rationale: Covariance (out TResponse) allows assignment compatibility (ICommand{object} can accept ICommand{string}), crucial for middleware and pipeline scenarios. Benefit: Enables flexible pipeline composition and type-safe command handling. (3) Async-Only API with ValueTask - Choice: ValueTask{T} instead of Task{T}. Rationale: ValueTask is more efficient for synchronous hot paths (can avoid allocation when result available immediately), aligns with Mediator library. Trade-off: Slightly more complex mental model than Task, but better performance. (4) IAsyncEnumerable for Streaming - Choice: IAsyncEnumerable{TResponse} for streaming commands. Rationale: Native .NET streaming abstraction, works well with async/await, cancellation, and LINQ, supported by C# 8.0+. Alternative Considered: IObservable{T}, custom stream interfaces. Rejected Because: IAsyncEnumerable is modern .NET standard for async streams. (5) CancellationToken on All Async Methods - Choice: Every async method accepts CancellationToken cancellationToken = default. Rationale: Proper async/await hygiene requires cancellation support throughout call stack, default parameter makes it optional for callers. Consequence: All implementations must respect cancellation tokens. (6) .NET Standard 2.1 Target - Choice: Target netstandard2.1 instead of net10.0. Rationale: Maximum compatibility - can be consumed by .NET Core 3.0+, .NET 5+, .NET Framework (via compatibility shims), Mono, Xamarin. Trade-off: Cannot use latest C# features requiring runtime support, but records and nullable reference types work fine. Alternative Considered: Multi-targeting (netstandard2.1;net10.0). Rejected Because: Adds complexity for marginal benefit; netstandard2.1 is sufficient. (7) No Implementation Code - Choice: Interfaces and minimal types only, no classes with logic. Rationale: This is abstraction layer, implementation goes in Synaxis package, keeps dependencies zero and surface area minimal. Exception: Small utility records or structs that are pure data. (8) Nullability Enabled - Choice: Nullable enabled in project file. Rationale: Null reference types are modern .NET standard, provides compile-time safety and better developer experience. Consequence: All reference types must be annotated (string? vs string). (9) Treat Warnings as Errors - Choice: TreatWarningsAsErrors true. Rationale: Foundation code should be pristine, warnings indicate potential issues that should be fixed not ignored. Consequence: Build fails on any warning (including XML documentation warnings). Directory Structure: src/Synaxis.Abstractions/ containing Commands/ (ICommand{T}.cs, IStreamRequest{T}.cs, INotification.cs), Execution/ (ICommandExecutor.cs, IStreamExecutor.cs), Providers/ (IProviderClient.cs, IChatProvider.cs, IEmbeddingProvider.cs, IImageProvider.cs, IAudioProvider.cs, IRerankProvider.cs), Routing/ (IProviderSelector.cs, IRoutingStrategy.cs, IRoutingContext.cs), Auth/ (IAuthenticationContext.cs, IApiKeyCredential.cs). Key Implementation Details: ICommand{TResponse} is empty marker interface with covariant out parameter, ICommandExecutor.ExecuteAsync uses ValueTask{TResponse} with CancellationToken default, IStreamExecutor.StreamAsync returns IAsyncEnumerable{TResponse}, IProviderClient has Name property and IsHealthyAsync method. Project File Requirements: TargetFramework netstandard2.1, LangVersion latest, Nullable enable, TreatWarningsAsErrors true, GenerateDocumentationFile true, PackageId Synaxis.Abstractions, Version 0.1.0-alpha. Build Validation: dotnet build produces zero warnings, dotnet list package shows zero dependencies, dotnet pack produces NuGet package. Acceptance Criteria: Project builds successfully, zero warnings enforced, zero external dependencies verified, target is netstandard2.1, all public types have XML documentation, nullable reference types enabled and annotated, can be packed into NuGet package, all marker interfaces defined, execution abstractions defined, provider abstractions defined, auth abstractions defined, routing abstractions defined. Risks: Interface design doesn't account for future requirements (mitigation: keep interfaces minimal, add methods via extension methods or new interfaces), .NET Standard 2.1 too limiting (mitigation: can multi-target later if needed).","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:05:32.475686903+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:05:32.475686903+01:00"}
{"id":"Synaxis-4gd","title":"Foundation: Establish SDK Architecture with Clean Abstractions, Versioned Contracts, and Architectural Decision Records","description":"Creates the architectural bedrock for Synaxis SDK-first design. This epic implements the foundational layer that all other components depend upon. Includes: (1) Synaxis.Abstractions - zero-dependency interfaces targeting .NET Standard 2.1 with marker interfaces (ICommand{T}, IStreamRequest{T}, INotification), execution abstractions (ICommandExecutor with ValueTask, IStreamExecutor with IAsyncEnumerable), provider contracts (IProviderClient, IChatProvider, IEmbeddingProvider, IImageProvider, IAudioProvider, IRerankProvider), routing abstractions (IProviderSelector, IRoutingStrategy), and auth abstractions (IAuthenticationContext, IApiKeyCredential). (2) Synaxis.Contracts - versioned data contracts in V1.Messages namespace (not DTOs), command interfaces (IChatCommand, IChatStreamCommand, etc.), auth contracts, and error model (SynaxisError with severity levels and categories). (3) ADRs 012-015 documenting SDK-first architecture, transport abstraction with Mediator, explicit registration pattern, and contracts versioning strategy. This is the critical path blocking all other work. Must achieve: zero dependencies in foundation packages, semantic naming (Messages not DTOs), stable interfaces designed for longevity (breaking changes require major version bumps), versioned contracts under V1 namespace, XML documentation on all public APIs, nullable reference types enabled, TreatWarningsAsErrors enforced. Success criteria: both packages build with zero warnings and zero external dependencies, test projects created with \u003e80% coverage, all 4 ADRs written and approved. Risks: Interface design mistakes are extremely expensive to fix later and require major version bumps, versioning strategy mistakes force ecosystem-wide updates, .NET Standard 2.1 vs .NET 10 decision affects compatibility matrix.","status":"in_progress","priority":0,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:08.641052313+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:42:15.569774083+01:00"}
{"id":"Synaxis-58b","title":"Documentation \u0026 Samples - Complete SDK Documentation and Working Examples","description":"Creates comprehensive documentation and working sample projects that demonstrate how to consume Synaxis in different scenarios. Documentation must be clear enough for developers, DevOps, and SaaS consumers to understand their specific use cases. Samples must be runnable and demonstrate best practices. Scope: (1) Documentation - README.md (project overview), docs/getting-started/ (quickstart guides for different personas), docs/architecture/ (deep dives), docs/packages/ (per-package documentation), docs/api/ (API reference). (2) Sample Projects - Minimal API example, Self-hosted server example, SaaS client example, Microservices example. Success Criteria: New user can get started in 5 minutes, All samples build and run without errors, Architecture decisions are clearly explained, API documentation covers all public types, Contributing guidelines are clear. Dependencies: All previous epics complete (need stable APIs to document). Risks: Documentation becomes outdated (mitigation: automate API doc generation), Samples don't work (mitigation: CI tests for samples).","status":"open","priority":3,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:51.939354359+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:04:51.939354359+01:00"}
{"id":"Synaxis-5qx","title":"Fix IntegrationTests compilation errors","status":"in_progress","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-07T22:25:42.879366634+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T22:26:37.320915092+01:00"}
{"id":"Synaxis-724","title":"Create ADR-012: SDK-First Package Architecture","description":"Objective: Write Architectural Decision Record 012 documenting the SDK-first package architecture, dependency rules, and versioning strategy. Context: This ADR explains why Synaxis uses a multi-tier package structure with strict dependency rules, and how it enables multiple consumption patterns (SDK, Gateway, SaaS). Content Requirements: Title: ADR-012: SDK-First Package Architecture. Status: Proposed (Accepted after review). Context: Synaxis must support multiple consumption patterns - Library (developers embed SDK), Gateway (DevOps deploy standalone), SaaS (customers use cloud API). Need clean architecture enabling all three without coupling. Decision: Create 4-tier package structure - Tier 1 Foundation (Synaxis.Abstractions, Synaxis.Contracts, optional Synaxis.Primitives) with zero deps, Tier 2 Core Implementation (Synaxis with Mediator, Synaxis.Providers.{Name} individual packages), Tier 3 Infrastructure (Synaxis.Client, Synaxis.Extensions.*), Tier 4 Transports \u0026 Adapters (Synaxis.Transport.*, Synaxis.Adapters.*), Tier 5 Server (Synaxis.Server thin composition). Dependency Rules: Abstractions never references Implementation, Contracts never references Implementation, Abstractions should not reference Contracts (avoid bidirectional), Contracts should not reference Abstractions (avoid bidirectional), if shared primitives needed create Synaxis.Primitives, all heavy deps go in Implementation or Adapters only. Unified Versioning: All first-party packages share same version (1.0.0, 1.1.0), breaking changes in Abstractions only on major versions. Consequences: Positive - clean separation, consumers pick only what they need, testable architecture, plugin architecture; Negative - more packages to manage, breaking changes affect entire ecosystem, steeper learning curve. File Location: docs/adr/012-sdk-first-package-architecture.md. Format: Follow existing ADR format (001-011). Review Process: Create as Proposed, review with team, mark Accepted when approved.","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:23.228853402+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:06:23.228853402+01:00"}
{"id":"Synaxis-7fq","title":"Create ADR-015: Contracts Versioning Strategy","description":"Objective: Write Architectural Decision Record 015 documenting the namespace-based versioning strategy and stability tiers for contracts. Context: Synaxis.Contracts used by SDK consumers (compile-time, long-lived) and SaaS API (runtime, must evolve gracefully). Need strategy allowing evolution without breaking consumers. Content Requirements: Title: ADR-015: Contracts Versioning Strategy. Status: Proposed. Context: Contracts used by SDK (compile-time dependency) and SaaS (runtime wire format). Need evolution without breaking, N-1 compatibility, easy to understand. Decision: Use namespace-based versioning with stability tiers. Namespace Versioning: Synaxis.Contracts.V1.Messages for current, Synaxis.Contracts.V2.Messages for next version (breaking changes). Each major version gets own namespace, minor versions don't change namespace, breaking changes only in major versions (V1 -\u003e V2). Stability Tiers: Tier 1 Most Stable (Synaxis.Abstractions) - marker interfaces, core abstractions, breaking changes only on major versions (2.0, 3.0), goal never break. Tier 2 Stable (Synaxis.Contracts.V1) - message types, command interfaces, error types, breaking changes only on major versions, goal N-1 compatibility. Tier 3 Evolving (Synaxis.Contracts.V1+) - new optional properties, new message types, new commands, additive changes only no breaking changes, goal backward compatible within major version. Messages Namespace (Not DTOs): Data types in Messages namespace, not Dtos. Version Compatibility: Within major version (1.0 -\u003e 1.1) - can add new optional properties, add new message types, add new commands, cannot remove properties, change types, or change behavior. Major version bump (1.x -\u003e 2.0) - can make breaking changes, new namespace V2, old namespace remains available (deprecation period), consumers migrate gradually. N-1 Compatibility: Support current version (V1) and previous version (V0 deprecated). After releasing V2: support V2 (current), V1 (previous), drop V0. Deprecation timeline: 12 months or next major version whichever is longer. Error Handling Across Versions: Error codes and structure remain stable, new error codes can be added, old error codes never removed (only deprecated). Consequences: Positive - clear versioning, predictable breaking changes, N-1 compatibility reduces upgrade pressure, namespace makes version explicit; Negative - namespace clutter with multiple versions, migration complexity, more packages to maintain (V1, V2, etc.), IntelliSense pollution. Implementation Notes: Start with V1 no V0, plan for V2 within 12-18 months, use Obsolete attribute before removal, provide migration guides, automated API compatibility checking in CI. Related: ADR-012 (where contracts live), ADR-014 (version selection in DI). File: docs/adr/015-contracts-versioning-strategy.md.","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:07:11.69969305+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:07:11.69969305+01:00"}
{"id":"Synaxis-8cc","title":"Archive Non-ADR Documentation","description":"Objective: Move all existing documentation from the docs/ directory (except the adr/ folder) and root-level markdown files to a dated archive location (docs/archive/2025-02-08/) using git mv to preserve file history. Background: The existing documentation was written for the previous monolithic InferenceGateway architecture and is no longer accurate for the SDK-first design, but contains valuable historical context that must be preserved. The docs/adr/ directory contains 11 approved ADRs (001-011) that remain relevant and must stay in place. Files to Archive - Root Level: README.md, AGENTS.md, IMPLEMENTATION_COMPLETE.md, IMPLEMENTATION_SUMMARY.md, TEST_COVERAGE_REPORT.md, BILLING_CACHE_IMPLEMENTATION.md. Files to Archive - docs/ Level: API.md, ARCHITECTURE.md, CONFIGURATION.md, CONTRIBUTING.md, COVERAGE_BASELINE.md, DEPLOYMENT.md, IDENTITY_API_KEY_IMPLEMENTATION.md, IMPLEMENTATION_COMPLETE.md, IMPLEMENTATION_SUMMARY.md, SECURITY.md, SYNAXIS_AGENTS_IMPLEMENTATION.md, TESTING.md, WEBSOCKET_REALTIME_UPDATES.md, workflows.md, 20260204-IMPLEMENTATION_SUMMARY.md, 20260204-TESTING.md. Directories to Archive: docs/plan/, docs/ops/, docs/reference/. Files to Preserve (DO NOT MOVE): docs/adr/README.md, docs/adr/001-stream-native-cqrs.md through docs/adr/011-dynamic-model-registry.md. Implementation: Use git mv to preserve history and blame information. Commands: mkdir -p docs/archive/2025-02-08 \u0026\u0026 git mv README.md docs/archive/2025-02-08/ \u0026\u0026 git mv AGENTS.md docs/archive/2025-02-08/ \u0026\u0026 git mv docs/API.md docs/archive/2025-02-08/ \u0026\u0026 ... (repeat for all files). Final commit: git commit -m 'docs: archive legacy documentation for SDK architecture transition - preserves ADRs 001-011'. Validation Checklist: After archival, running ls docs/ shows only 'adr/ archive/', running ls docs/adr/ shows all 11 ADR files plus README.md, running ls docs/archive/2025-02-08/ shows all archived files, git log shows descriptive commit, no build errors from missing documentation references. Decision Rationale: Use git mv over regular mv to preserve file history and blame information; this maintains audit trail and allows historical research. Risks: Breaking relative links in archived documents (mitigation: acceptable as archived docs are historical reference only), losing important documentation (mitigation: archiving preserves everything, nothing deleted), confusion about where current docs live (mitigation: new README will clarify SDK-first architecture).","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:05:09.56827315+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:05:09.56827315+01:00"}
{"id":"Synaxis-a1r","title":"Transport Layer - HTTP, gRPC, and WebSocket Implementations","description":"Implements transport-specific packages that expose Synaxis functionality over different protocols. Each transport is a separate NuGet package that can be optionally consumed. All transports use ICommandExecutor and IStreamExecutor from Foundation, ensuring consistent behavior regardless of protocol. Scope: (1) Synaxis.Transport.Http - REST API with JSON, Server-Sent Events (SSE) for streaming, ASP.NET Core controllers, authentication middleware, OpenAPI/Swagger support. (2) Synaxis.Transport.Grpc - gRPC services with Protocol Buffers, server and client code generation, streaming support via gRPC server streaming, reflection service for debugging. (3) Synaxis.Transport.WebSocket - Raw WebSocket support for real-time bidirectional communication, frame handling, connection management. Key Design Pattern: All transports are thin adapters that deserialize requests into Commands, call ICommandExecutor/IStreamExecutor, serialize responses. No business logic in transports - pure protocol adaptation. Dependencies: Epic 1 (Foundation), Epic 2 (Core Implementation - need handlers to execute). Success Criteria: All three transport packages build with zero warnings, HTTP transport handles REST and SSE correctly, gRPC transport handles unary and streaming calls, WebSocket transport handles frames, Each transport has explicit DI registration (AddSynaxisTransport*), Each transport has endpoint mapping (MapSynaxisTransport*), Integration tests prove end-to-end functionality. Risks: Protocol differences cause inconsistent behavior (mitigation: all use same executor), Performance differences between transports (mitigation: document and benchmark), WebSocket complexity (mitigation: well-tested frame handling).","status":"open","priority":2,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:40.231455243+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:04:40.231455243+01:00"}
{"id":"Synaxis-ajl","title":"Create ADR-013: Transport Abstraction with Mediator","description":"Objective: Write Architectural Decision Record 013 documenting the use of MartinOthamar.Mediator for CQRS and the transport abstraction pattern. Context: Synaxis must support HTTP, gRPC, WebSocket, SignalR, Microsoft.Agents, MCP - all with same business logic. Need clean abstraction to avoid duplication. Content Requirements: Title: ADR-013: Transport Abstraction with Mediator. Status: Proposed. Context: Multiple transport protocols needed (HTTP/REST for compatibility, gRPC for performance, WebSocket for real-time, SignalR for .NET, Agents for orchestration, MCP for protocol). All must share same business logic. Decision: Use MartinOthamar.Mediator as CQRS backbone with clean transport abstractions. Architecture: Transport Layer (REST, gRPC, SignalR, Agents, MCP) -\u003e Abstraction Layer (ICommandExecutor, IStreamExecutor) -\u003e Mediator Layer (Commands -\u003e Handlers -\u003e Behaviors) -\u003e Business Logic (Routing, Provider Selection). Key Abstractions: ICommandExecutor.ExecuteAsync{TCommand, TResponse} with ValueTask, IStreamExecutor.StreamAsync{TCommand, TResponse} with IAsyncEnumerable. Pattern: Commands implement ICommand{TResponse}, Handlers implement Mediator's IRequestHandler, Streaming uses IStreamRequest{T} and IAsyncEnumerable, Transports delegate to ICommandExecutor/IStreamExecutor, Business logic lives in Handlers never in transports. Transport-Specific Code Location: Only in adapter packages, never in business logic. Consequences: Positive - single business logic implementation, easy to add new transports, testable, Mediator is source-generated zero reflection; Negative - learning curve for Mediator, requires understanding source generators, IAsyncEnumerable limitations in some transports, harder debugging with pipelines. Related: ADR-012 (package structure enables this), ADR-014 (DI registration). File: docs/adr/013-transport-abstraction-mediator.md.","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:31.550760485+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:06:31.550760485+01:00"}
{"id":"Synaxis-bvl","title":"Fix IntegrationTests CS compilation errors (API breaking changes)","status":"in_progress","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-07T22:52:20.872248053+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T22:52:25.269788664+01:00"}
{"id":"Synaxis-d9k","title":"Fix SA1018 nullable type spacing errors in Infrastructure project","status":"open","priority":2,"issue_type":"bug","owner":"rudimar@outlook.com","created_at":"2026-02-07T21:49:46.007315158+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T21:49:46.007315158+01:00"}
{"id":"Synaxis-eeg","title":"Fix failing Infrastructure.Tests","notes":"Infrastructure.Tests builds successfully (0 errors) after analyzer fixes, but 26 tests are failing:\n\nCategories of failures:\n1. SoftDeleteInterceptorTests (13 failures) - Database entities not being soft-deleted properly\n2. ControlPlaneExtensionsTests (4 failures) - Missing ILogger\u003cControlPlaneDbContext\u003e registration\n3. SecurityConfigurationValidatorTests (4 failures) - Weak secret validation logic issues\n4. ApiKeyServiceTests (2 failures) - Error message text mismatches\n5. TenantResolutionMiddlewareTests (1 failure) - Mock verification issue\n6. IdentityManagerTests (1 failure) - Null token issue\n7. CopilotSdkClientTests (1 failure) - Dispose not called\n\nThese are pre-existing test failures unrelated to the analyzer fixes.\nBuild: ✅ (0 errors, 0 warnings)\nTests: ❌ (26 failures)","status":"open","priority":2,"issue_type":"bug","owner":"rudimar@outlook.com","created_at":"2026-02-07T22:21:34.383671581+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T22:21:43.572854752+01:00"}
{"id":"Synaxis-iui","title":"Create Synaxis.Contracts Project - Versioned Data Contracts with Messages Namespace","description":"Objective: Create the data contracts package that defines versioned data shapes for Synaxis SDK, using Messages namespace (not DTOs) under V1 versioning. Context: This package is consumed by both SDK users (compile-time dependency) and SaaS API (runtime wire format). Contracts must be stable, versioned, and designed for evolution. Critical Design Decisions: (1) Messages Namespace (Not DTOs) - Choice: Use Synaxis.Contracts.V1.Messages namespace instead of Dtos. Rationale: DTO (Data Transfer Object) is an implementation detail implying serialization, Messages conveys semantic meaning (these are the messages passed between components). Alternative Considered: Dtos, Types, Data. Rejected Because: Messages is semantic and clear, DTOs implies anemic objects, Types is too generic, Data is ambiguous. (2) Versioned with V1 Namespace - Choice: Synaxis.Contracts.V1.Messages for current version. Rationale: Namespace-based versioning allows multiple versions to coexist, enables gradual migration, makes version explicit in code. Future versions: Synaxis.Contracts.V2.Messages. Breaking changes only in major versions (V1 -\u003e V2). (3) Records for Immutability - Choice: Use C# 9.0 records for all message types. Rationale: Records provide value semantics, immutability by default, concise syntax, built-in equality/hashing, pattern matching support. Example: public record ChatMessage(string Role, string Content); (4) Init-Only Properties - Choice: Use init-only properties for flexibility within immutability. Rationale: Allows object initializer syntax while maintaining immutability after construction. Syntax: public string Model { get; init; } = string.Empty; (5) Nullability Annotations - Choice: Enable nullable reference types with full annotation. Rationale: Compile-time null safety, better IntelliSense, documents nullability contract. Pattern: Required properties are non-nullable (string), optional properties are nullable (string?). (6) XML Documentation - Choice: Require XML documentation on all public types. Rationale: Foundation for IntelliSense, enables GenerateDocumentationFile, professional API surface. Directory Structure: src/Synaxis.Contracts/ containing V1/ directory with Messages/ (ChatMessage.cs, ChatResponse.cs, ChatStreamChunk.cs, EmbeddingRequest.cs, EmbeddingResponse.cs, ImageGenerationRequest.cs, ImageGenerationResponse.cs, AudioTranscriptionRequest.cs, AudioTranscriptionResponse.cs, RerankRequest.cs, RerankResponse.cs, BatchRequest.cs, BatchResponse.cs, UsageInfo.cs), Commands/ (IChatCommand.cs, IChatStreamCommand.cs, IEmbeddingCommand.cs, IImageGenerationCommand.cs, IAudioTranscriptionCommand.cs, IRerankCommand.cs, ICreateBatchCommand.cs, ICancelBatchCommand.cs), Auth/ (IAuthenticationContext.cs, IApiKeyCredential.cs), Errors/ (SynaxisError.cs, ErrorSeverity.cs, ErrorCategory.cs, IErrorResponse.cs). Key Implementation Details: ChatMessage is record with Role, Content, optional Name, ChatResponse has Id, Object, Created, Model, Message, Usage, SystemFingerprint, UsageInfo has PromptTokens, CompletionTokens, TotalTokens, SynaxisError has Code, Message, Severity, Category, Details, IChatCommand implements Abstractions.ICommand{ChatResponse} with Model, Messages, Temperature, MaxTokens, UserId, OrganizationId, TenantId. Project File: References Synaxis.Abstractions only, TargetFramework netstandard2.1, Nullable enable, TreatWarningsAsErrors true, GenerateDocumentationFile true, PackageId Synaxis.Contracts, Version 0.1.0-alpha. Build Validation: dotnet build succeeds with zero warnings, references only Synaxis.Abstractions, can be packed to NuGet. Acceptance Criteria: Project builds with zero warnings, references only Abstractions package, all contracts use Messages namespace (not Dtos), all contracts versioned under V1 namespace, records used for all message types, init-only properties for optional fields, nullability annotations throughout, XML documentation on all public types. Risks: Versioning strategy doesn't account for all scenarios (mitigation: ADR-015 defines comprehensive strategy), namespace naming causes confusion (mitigation: consistent V1.Messages pattern, documented in ADR-015).","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:05:50.74873526+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:05:50.74873526+01:00"}
{"id":"Synaxis-r4j","title":"Create ADR-014: Explicit Registration Pattern","description":"Objective: Write Architectural Decision Record 014 documenting the explicit DI registration pattern and prohibition of auto-discovery. Context: Synaxis has many optional components (transports, adapters, providers) and needs predictable, discoverable configuration without runtime surprises. Content Requirements: Title: ADR-014: Explicit Registration Pattern. Status: Proposed. Context: Many optional components, need explicit and predictable configuration, easy to debug, self-documenting. Auto-discovery causes runtime surprises. Decision: Use explicit DI registration only, NO auto-discovery, NO assembly scanning. Registration Pattern: services.AddSynaxis() for core, services.AddSynaxisTransportHttp() for HTTP, services.AddSynaxisTransportGrpc() for gRPC, services.AddSynaxisAdapterSignalR() for SignalR, app.MapSynaxisTransportHttp() for endpoint mapping. Naming Convention: Core uses AddSynaxis(), Transports use AddSynaxisTransport{Name}(), Adapters use AddSynaxisAdapter{Name}(), Providers use Add{ProviderName}Provider() inside options, Mapping uses MapSynaxisTransport{Name}() and MapSynaxisAdapter{Name}(). Per-Package Registration: Each package provides its own extensions, no central registration. Registration Order: 1. Core (AddSynaxis), 2. Transports (AddSynaxisTransport*), 3. Adapters (AddSynaxisAdapter*), 4. Use middleware (UseSynaxisTransport*), 5. Map endpoints (MapSynaxis*). What NOT to Do: No AddSynaxisAll(), no assembly scanning, no automatic transport registration, no convention-based configuration. Consequences: Positive - explicit and predictable, IntelliSense shows options, no runtime surprises, clear dependency graph, easy to debug; Negative - more verbose setup, must document registration order, easy to forget Map* methods, breaking changes require updating registration code. Implementation Notes: Use IOptions{T} pattern, validate at startup (fail fast), meaningful error messages if order wrong, consider source generators for validation. Related: ADR-012 (package structure), ADR-013 (what gets registered). File: docs/adr/014-explicit-registration-pattern.md.","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:58.233933867+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:06:58.233933867+01:00"}
{"id":"Synaxis-v49","title":"Create Comprehensive Test Suite for Synaxis.Abstractions","description":"Objective: Create unit test project for Synaxis.Abstractions with comprehensive coverage of interfaces, marker types, and compilation verification. Context: While Abstractions contains only interfaces and no implementation logic, tests are critical to verify: (1) Interfaces can be implemented by external code, (2) Generic constraints work as expected, (3) Covariance/contravariance behaves correctly, (4) Nullability annotations are correct, (5) Project references and builds work. Test Strategy: (1) Compilation Tests - Verify Abstractions project compiles with zero warnings and zero errors, Verify zero external dependencies, Verify correct target framework. (2) Implementation Tests - Create test implementations of each interface to verify they can be implemented, Verify generic constraints are satisfiable, Verify covariance works (can assign ICommand{string} to ICommand{object}). (3) Contract Tests - Verify marker interfaces are truly empty, Verify async method signatures are correct, Verify CancellationToken parameters exist. Directory Structure: tests/Synaxis.Abstractions.Tests/ containing CompilationTests.cs (Build_Succeeds_With_Zero_Warnings, Has_Zero_External_Dependencies, Targets_NetStandard_2_1), InterfaceImplementationTests.cs (ICommand_Can_Be_Implemented, IStreamRequest_Can_Be_Implemented, ICommandExecutor_Can_Be_Implemented, IStreamExecutor_Can_Be_Implemented, IProviderClient_Can_Be_Implemented, Covariance_Works_For_Commands), MarkerInterfaceTests.cs (ICommand_Is_Empty_Marker, IStreamRequest_Is_Empty_Marker, INotification_Is_Empty_Marker). Test Examples: [Fact] public void ICommand_Can_Be_Implemented() { var command = new TestCommand(); Assert.IsAssignableFrom{ICommand{string}}(command); } private record TestCommand : ICommand{string} { }. Project File: Tests/Synaxis.Abstractions.Tests.csproj references Synaxis.Abstractions, uses xUnit, FluentAssertions, Microsoft.NET.Test.Sdk. Coverage Target: 100% of public API surface (interfaces must be implementable). Acceptance Criteria: All tests pass, 100% compilation success rate, zero test warnings, interfaces proven implementable, covariance verified.","status":"open","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:04.17453693+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:06:04.17453693+01:00"}
{"id":"Synaxis-yeo","title":"SDK Core Implementation - Commands, Handlers, Behaviors, and Provider Packages","description":"Builds the core implementation layer on top of Foundation. Creates the Synaxis package containing command implementations, Mediator handlers, pipeline behaviors, and execution implementations. Also creates all provider packages (Synaxis.Providers.*) as separate NuGet packages. This is the engine that powers all transports and adapters. Scope: (1) Synaxis project with Commands/ (concrete command records implementing contract interfaces), Handlers/ (Mediator request handlers containing business logic), Behaviors/ (cross-cutting concerns via Mediator pipelines), Execution/ (ICommandExecutor and IStreamExecutor implementations using Mediator), Routing/ (provider selection logic). (2) Synaxis.Providers.OpenAI - HTTP client for OpenAI API, implements IChatProvider, IEmbeddingProvider, etc. (3) Synaxis.Providers.Azure - Azure OpenAI Service integration. (4) Synaxis.Providers.Anthropic - Claude API integration. (5) Synaxis.Providers.Google - Gemini API integration. (6) Additional providers as needed. Key Implementation Pattern: Commands are records implementing contract interfaces (e.g., ChatCommand implements IChatCommand), Handlers implement Mediator's IRequestHandler{T, TResponse}, Behaviors implement IPipelineBehavior{TMessage, TResponse} for cross-cutting concerns (logging, validation, metrics, auth, transactions), Executor implementations delegate to Mediator's Send and CreateStream methods. Pipeline Behaviors: LoggingBehavior (structured logging with correlation IDs), ValidationBehavior (input validation using FluentValidation or similar), MetricsBehavior (Prometheus metrics collection), AuthorizationBehavior (RBAC checks), TransactionBehavior (database transaction wrapping). Dependencies: Epic 1 (Foundation) must be complete with Abstractions and Contracts packages available. Success Criteria: Synaxis package builds with zero warnings, all handlers have unit tests with \u003e80% coverage, at least 3 provider packages created and tested (OpenAI, Azure, Anthropic), pipeline behaviors chain correctly, ICommandExecutor and IStreamExecutor functional, zero coupling between handlers (each is independent). Risks: Handler complexity grows quickly (mitigation: keep handlers focused, extract helpers), Provider APIs change (mitigation: version provider packages independently), Performance issues with Mediator (mitigation: source generators make it fast, benchmark if needed).","status":"open","priority":1,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:32.714585849+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:04:32.714585849+01:00"}
