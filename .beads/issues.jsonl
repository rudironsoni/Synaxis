{"id":"Synaxis-0hr","title":"Create Comprehensive Test Suite for Synaxis.Contracts","description":"Objective: Create unit test project for Synaxis.Contracts with comprehensive coverage of message types, serialization, immutability, and contract validation. Context: Contracts are data shapes that will be serialized/deserialized across process boundaries (HTTP, gRPC, etc.), so testing must verify serialization compatibility, immutability guarantees, and record semantics. Test Categories: (1) Construction Tests - Verify records can be constructed, Verify required properties enforced, Verify optional properties work with init, Verify object initializer syntax works. (2) Immutability Tests - Verify records are immutable after construction, Verify with-expression creates new instance, Verify init-only properties cannot be set after construction. (3) Serialization Tests - Verify JSON serialization works (System.Text.Json), Verify protobuf compatibility (if using protobuf-net), Verify records serialize/deserialize correctly, Verify null handling in serialization. (4) Equality Tests - Verify records have value equality, Verify equality ignores reference identity, Verify GetHashCode is consistent. Directory Structure: tests/Synaxis.Contracts.Tests/ containing Messages/ChatMessageTests.cs (Can_Be_Constructed, Is_Immutable, Has_Value_Equality, Serializes_To_Json), Messages/ChatResponseTests.cs, SerializationTests.cs (All_Messages_Serialize_To_Json, All_Messages_Deserialize_From_Json, Null_Handling_Works), ImmutabilityTests.cs (Records_Are_Immutable, With_Expression_Creates_New_Instance). Test Examples: [Fact] public void ChatMessage_Can_Be_Constructed() { var message = new ChatMessage('user', 'Hello'); Assert.Equal('user', message.Role); Assert.Equal('Hello', message.Content); } [Fact] public void ChatMessage_Is_Immutable() { var message = new ChatMessage('user', 'Hello'); // Should not compile: message.Role = 'assistant'; }. Project File: Tests/Synaxis.Contracts.Tests.csproj references Synaxis.Contracts, uses xUnit, FluentAssertions, System.Text.Json for serialization tests. Coverage Target: \u003e80% line coverage, 100% of public message types tested. Acceptance Criteria: All tests pass, \u003e80% code coverage, all message types proven serializable, immutability verified, equality contracts verified.","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:14.425081509+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.689344334+01:00","closed_at":"2026-02-08T14:15:48.689344334+01:00","close_reason":"Closed"}
{"id":"Synaxis-0zv","title":"Create Synaxis.Transport.Grpc Package - High-Performance gRPC Services","description":"Objective: Create the gRPC transport package for high-performance scenarios requiring lower latency than HTTP/JSON. gRPC uses Protocol Buffers for efficient binary serialization and HTTP/2 for transport. Architecture: Protocol Buffer definitions (.proto files), gRPC service implementations, Server-side streaming for real-time responses, Reflection service for debugging, Interceptors for cross-cutting concerns. Project Structure: src/Synaxis.Transport.Grpc/ containing Protos/synaxis/v1/chat.proto, Protos/synaxis/v1/common.proto, Services/ChatGrpcService.cs, Interceptors/AuthenticationInterceptor.cs, Interceptors/LoggingInterceptor.cs, DependencyInjection/GrpcTransportServiceCollectionExtensions.cs. Protobuf Definition: syntax = 'proto3'; package synaxis.v1; service ChatService { rpc CreateCompletion (ChatRequest) returns (ChatResponse); rpc StreamCompletion (ChatRequest) returns (stream ChatStreamChunk); }. Implementation: ChatGrpcService extends generated base class, delegates to ICommandExecutor/IStreamExecutor. DI Registration: AddSynaxisTransportGrpc(), MapSynaxisTransportGrpc(). Testing: Unit tests for service implementations, Integration tests with gRPC client, Performance benchmarks vs HTTP. Dependencies: Synaxis.Abstractions, Synaxis.Contracts, Synaxis, Grpc.AspNetCore, Google.Protobuf. Estimated effort: 6-8 hours. Dependencies: Epic 1, Epic 2 complete.","status":"closed","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:36.82898841+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:24.888043901+01:00","closed_at":"2026-02-08T15:40:24.888043901+01:00","close_reason":"Transport and Adapter packages created successfully with zero warnings: HTTP (REST + SSE), gRPC (Protobuf), WebSocket, SignalR, and Microsoft.Agents adapters all build and implement proper abstractions.","dependencies":[{"issue_id":"Synaxis-0zv","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:07.748054343+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-33p","title":"System Adapters - SignalR, Microsoft.Agents, and MCP Integration","description":"Implements adapters for system-specific integrations beyond basic transports. These are higher-level integrations that may use transports internally but provide specialized functionality. SignalR for real-time .NET applications, Microsoft.Agents for agent orchestration, and MCP for Model Context Protocol support. Scope: (1) Synaxis.Adapters.SignalR - Real-time hubs for streaming, Connection management, Groups for multi-user scenarios. (2) Synaxis.Adapters.Agents - Microsoft.Agents SDK integration, ActivityHandler implementation, Agent orchestration, Tool calling. (3) Synaxis.Adapters.Mcp - Model Context Protocol implementation, Tool definitions, Multiple transport support (stdio, HTTP, SSE). Key Design: All adapters use ICommandExecutor/IStreamExecutor from Foundation, Provide specialized APIs for their ecosystems, Explicit registration required. Dependencies: Epic 1 (Foundation), Epic 2 (Core Implementation). Success Criteria: SignalR hubs support streaming chat, Agents adapter handles Bot Framework activities, MCP adapter exposes tools via protocol, Each adapter has explicit DI registration (AddSynaxisAdapter*), Integration tests for each adapter. Risks: SignalR and Agents have different streaming models (mitigation: abstraction layer handles differences), MCP protocol is evolving (mitigation: follow spec closely, plan for versioning), Adapter complexity grows quickly (mitigation: keep adapters thin, delegate to core).","status":"closed","priority":2,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:46.837836493+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:35.025226988+01:00","closed_at":"2026-02-08T15:40:35.025226988+01:00","close_reason":"All child tasks completed successfully. Epic 3: HTTP, gRPC, WebSocket transports with zero warnings. Epic 4: SignalR, Agents, MCP adapters with zero warnings."}
{"id":"Synaxis-3sl","title":"Create Synaxis.Abstractions Project - Zero-Dependency Foundation Interfaces","description":"Objective: Create the foundational NuGet package that defines all interfaces and abstractions for the Synaxis SDK with zero external dependencies, targeting .NET Standard 2.1 for maximum compatibility. Context: This is the most critical package in the entire ecosystem - it defines contracts that transports implement (ICommandExecutor, IStreamExecutor), providers implement (IChatProvider, IEmbeddingProvider, etc.), application code consumes (ICommand{T}, IStreamRequest{T}), and external developers extend (custom providers, custom behaviors). Breaking changes here require major version bumps and force all consumers to update. Architectural Decisions: (1) Use Marker Interfaces (Empty Interfaces) - Choice: public interface ICommand{out TResponse} { } (empty). Rationale: Marker interfaces provide type safety without imposing constraints, allow type system to enforce only command types passed to executors, keep interface minimal and extensible. Alternative Considered: Base classes with virtual methods. Rejected Because: Base classes impose inheritance hierarchy, limit flexibility, create versioning challenges. (2) Generic Type Parameters for Command/Response Types - Choice: ICommand{TResponse} with covariant out parameter. Rationale: Covariance (out TResponse) allows assignment compatibility (ICommand{object} can accept ICommand{string}), crucial for middleware and pipeline scenarios. Benefit: Enables flexible pipeline composition and type-safe command handling. (3) Async-Only API with ValueTask - Choice: ValueTask{T} instead of Task{T}. Rationale: ValueTask is more efficient for synchronous hot paths (can avoid allocation when result available immediately), aligns with Mediator library. Trade-off: Slightly more complex mental model than Task, but better performance. (4) IAsyncEnumerable for Streaming - Choice: IAsyncEnumerable{TResponse} for streaming commands. Rationale: Native .NET streaming abstraction, works well with async/await, cancellation, and LINQ, supported by C# 8.0+. Alternative Considered: IObservable{T}, custom stream interfaces. Rejected Because: IAsyncEnumerable is modern .NET standard for async streams. (5) CancellationToken on All Async Methods - Choice: Every async method accepts CancellationToken cancellationToken = default. Rationale: Proper async/await hygiene requires cancellation support throughout call stack, default parameter makes it optional for callers. Consequence: All implementations must respect cancellation tokens. (6) .NET Standard 2.1 Target - Choice: Target netstandard2.1 instead of net10.0. Rationale: Maximum compatibility - can be consumed by .NET Core 3.0+, .NET 5+, .NET Framework (via compatibility shims), Mono, Xamarin. Trade-off: Cannot use latest C# features requiring runtime support, but records and nullable reference types work fine. Alternative Considered: Multi-targeting (netstandard2.1;net10.0). Rejected Because: Adds complexity for marginal benefit; netstandard2.1 is sufficient. (7) No Implementation Code - Choice: Interfaces and minimal types only, no classes with logic. Rationale: This is abstraction layer, implementation goes in Synaxis package, keeps dependencies zero and surface area minimal. Exception: Small utility records or structs that are pure data. (8) Nullability Enabled - Choice: Nullable enabled in project file. Rationale: Null reference types are modern .NET standard, provides compile-time safety and better developer experience. Consequence: All reference types must be annotated (string? vs string). (9) Treat Warnings as Errors - Choice: TreatWarningsAsErrors true. Rationale: Foundation code should be pristine, warnings indicate potential issues that should be fixed not ignored. Consequence: Build fails on any warning (including XML documentation warnings). Directory Structure: src/Synaxis.Abstractions/ containing Commands/ (ICommand{T}.cs, IStreamRequest{T}.cs, INotification.cs), Execution/ (ICommandExecutor.cs, IStreamExecutor.cs), Providers/ (IProviderClient.cs, IChatProvider.cs, IEmbeddingProvider.cs, IImageProvider.cs, IAudioProvider.cs, IRerankProvider.cs), Routing/ (IProviderSelector.cs, IRoutingStrategy.cs, IRoutingContext.cs), Auth/ (IAuthenticationContext.cs, IApiKeyCredential.cs). Key Implementation Details: ICommand{TResponse} is empty marker interface with covariant out parameter, ICommandExecutor.ExecuteAsync uses ValueTask{TResponse} with CancellationToken default, IStreamExecutor.StreamAsync returns IAsyncEnumerable{TResponse}, IProviderClient has Name property and IsHealthyAsync method. Project File Requirements: TargetFramework netstandard2.1, LangVersion latest, Nullable enable, TreatWarningsAsErrors true, GenerateDocumentationFile true, PackageId Synaxis.Abstractions, Version 0.1.0-alpha. Build Validation: dotnet build produces zero warnings, dotnet list package shows zero dependencies, dotnet pack produces NuGet package. Acceptance Criteria: Project builds successfully, zero warnings enforced, zero external dependencies verified, target is netstandard2.1, all public types have XML documentation, nullable reference types enabled and annotated, can be packed into NuGet package, all marker interfaces defined, execution abstractions defined, provider abstractions defined, auth abstractions defined, routing abstractions defined. Risks: Interface design doesn't account for future requirements (mitigation: keep interfaces minimal, add methods via extension methods or new interfaces), .NET Standard 2.1 too limiting (mitigation: can multi-target later if needed).","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:05:32.475686903+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.676361662+01:00","closed_at":"2026-02-08T14:15:48.676361662+01:00","close_reason":"Closed"}
{"id":"Synaxis-4gd","title":"Foundation: Establish SDK Architecture with Clean Abstractions, Versioned Contracts, and Architectural Decision Records","description":"Creates the architectural bedrock for Synaxis SDK-first design. This epic implements the foundational layer that all other components depend upon. Includes: (1) Synaxis.Abstractions - zero-dependency interfaces targeting .NET Standard 2.1 with marker interfaces (ICommand{T}, IStreamRequest{T}, INotification), execution abstractions (ICommandExecutor with ValueTask, IStreamExecutor with IAsyncEnumerable), provider contracts (IProviderClient, IChatProvider, IEmbeddingProvider, IImageProvider, IAudioProvider, IRerankProvider), routing abstractions (IProviderSelector, IRoutingStrategy), and auth abstractions (IAuthenticationContext, IApiKeyCredential). (2) Synaxis.Contracts - versioned data contracts in V1.Messages namespace (not DTOs), command interfaces (IChatCommand, IChatStreamCommand, etc.), auth contracts, and error model (SynaxisError with severity levels and categories). (3) ADRs 012-015 documenting SDK-first architecture, transport abstraction with Mediator, explicit registration pattern, and contracts versioning strategy. This is the critical path blocking all other work. Must achieve: zero dependencies in foundation packages, semantic naming (Messages not DTOs), stable interfaces designed for longevity (breaking changes require major version bumps), versioned contracts under V1 namespace, XML documentation on all public APIs, nullable reference types enabled, TreatWarningsAsErrors enforced. Success criteria: both packages build with zero warnings and zero external dependencies, test projects created with \u003e80% coverage, all 4 ADRs written and approved. Risks: Interface design mistakes are extremely expensive to fix later and require major version bumps, versioning strategy mistakes force ecosystem-wide updates, .NET Standard 2.1 vs .NET 10 decision affects compatibility matrix.","status":"closed","priority":0,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:08.641052313+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:17:07.064192452+01:00","closed_at":"2026-02-08T14:17:07.064192452+01:00","close_reason":"All child tasks completed: Synaxis.Abstractions and Synaxis.Contracts packages created with zero dependencies, ADRs 012-015 documented, comprehensive test suites added (129 tests passing), legacy docs archived. Foundation complete."}
{"id":"Synaxis-4hl","title":"Create Synaxis.Adapters.SignalR - Real-Time Hubs for .NET Applications","description":"Objective: Create the SignalR adapter package for real-time communication in .NET applications. SignalR provides persistent connections and automatic fallback to Server-Sent Events or Long Polling when WebSockets unavailable. Architecture: SignalR Hub implementations, Connection management, Group support for multi-user scenarios, Streaming via SignalR's streaming hub methods, Integration with IStreamExecutor. Project Structure: src/Synaxis.Adapters.SignalR/ containing Hubs/ChatHub.cs (streaming hub methods), Hubs/SynaxisHub.cs, Connection/ConnectionManager.cs, Groups/GroupManager.cs, DependencyInjection/SignalRAdapterServiceCollectionExtensions.cs. Hub Implementation: ChatHub has StreamChat method returning IAsyncEnumerable{ChatStreamChunk}, SendChat method returning ChatResponse. Group Support: JoinGroup, LeaveGroup methods for multi-user scenarios. Configuration: public class SignalRAdapterOptions { public string Path { get; set; } = '/synaxis'; public bool EnableDetailedErrors { get; set; } = false; public int MaximumReceiveMessageSize { get; set; } = 1024 * 1024; }. DI Registration: AddSynaxisAdapterSignalR(), MapSynaxisAdapterSignalR(). Testing: Unit tests for hub methods, Integration tests with SignalR client, Group functionality tests. Dependencies: Synaxis.Abstractions, Synaxis.Contracts, Synaxis, Microsoft.AspNetCore.SignalR. Estimated effort: 6-8 hours. Dependencies: Epic 1, Epic 2 complete.","status":"closed","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:32:03.815119015+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:24.908255492+01:00","closed_at":"2026-02-08T15:40:24.908255492+01:00","close_reason":"Transport and Adapter packages created successfully with zero warnings: HTTP (REST + SSE), gRPC (Protobuf), WebSocket, SignalR, and Microsoft.Agents adapters all build and implement proper abstractions.","dependencies":[{"issue_id":"Synaxis-4hl","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:09.502594312+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-4oj","title":"Create Synaxis.Providers.Azure Package - Azure OpenAI Service Integration","description":"Objective: Create the Azure OpenAI Service provider package implementing provider interfaces for Azure's managed OpenAI offering. Context: Azure OpenAI is enterprise-focused with additional features like private endpoints, managed identity, and compliance certifications. Key Differences from OpenAI: Azure uses deployment-specific endpoints (/openai/deployments/{deployment-id}/chat/completions), Supports Azure AD authentication (managed identity), Different rate limiting and quota model, Regional deployment model. Implementation: Similar structure to OpenAI provider but with Azure-specific authentication and endpoint construction. Support both API key and Azure AD (DefaultAzureCredential) authentication. Project Structure: src/Synaxis.Providers.Azure/ containing AzureChatProvider.cs, AzureEmbeddingProvider.cs, AzureClient.cs, Configuration/AzureOpenAIOptions.cs (Endpoint, DeploymentId, ApiKey or UseAzureAd), DependencyInjection/AzureProviderExtensions.cs. Authentication Modes: API Key (Header api-key: {apiKey}), Azure AD (Use Azure.Identity.DefaultAzureCredential to get token). Endpoint Construction: {Endpoint}/openai/deployments/{DeploymentId}/chat/completions?api-version=2024-02-01. Estimated effort: 4-6 hours. Dependencies: Epic 1 complete.","status":"closed","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:13.71390089+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:16:27.970777597+01:00","closed_at":"2026-02-08T15:16:27.970777597+01:00","close_reason":"All Epic 2 tasks completed successfully. Core implementation with Mediator integration, 3 provider packages (OpenAI, Azure, Anthropic), and comprehensive test suite (99 tests passing) all build with zero warnings.","dependencies":[{"issue_id":"Synaxis-4oj","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:06.875206248+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-58b","title":"Documentation \u0026 Samples - Complete SDK Documentation and Working Examples","description":"Creates comprehensive documentation and working sample projects that demonstrate how to consume Synaxis in different scenarios. Documentation must be clear enough for developers, DevOps, and SaaS consumers to understand their specific use cases. Samples must be runnable and demonstrate best practices. Scope: (1) Documentation - README.md (project overview), docs/getting-started/ (quickstart guides for different personas), docs/architecture/ (deep dives), docs/packages/ (per-package documentation), docs/api/ (API reference). (2) Sample Projects - Minimal API example, Self-hosted server example, SaaS client example, Microservices example. Success Criteria: New user can get started in 5 minutes, All samples build and run without errors, Architecture decisions are clearly explained, API documentation covers all public types, Contributing guidelines are clear. Dependencies: All previous epics complete (need stable APIs to document). Risks: Documentation becomes outdated (mitigation: automate API doc generation), Samples don't work (mitigation: CI tests for samples).","status":"open","priority":3,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:51.939354359+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T13:04:51.939354359+01:00"}
{"id":"Synaxis-5qx","title":"Fix IntegrationTests compilation errors","status":"in_progress","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-07T22:25:42.879366634+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T22:26:37.320915092+01:00"}
{"id":"Synaxis-67z","title":"Create Comprehensive Unit Tests for Synaxis Core Implementation","description":"Objective: Create unit test project for Synaxis package covering command handlers, pipeline behaviors, and execution implementations. Testing Strategy: (1) Handler Tests - Mock dependencies (IProviderSelector, providers), Test happy path execution, Test error handling, Test cancellation, Verify correct provider selected. (2) Behavior Tests - Test LoggingBehavior logs correctly, Test ValidationBehavior throws on invalid input, Test MetricsBehavior records metrics, Test AuthorizationBehavior enforces permissions, Verify behaviors chain in correct order. (3) Executor Tests - Test MediatorCommandExecutor delegates to IMediator.Send, Test MediatorStreamExecutor delegates to IMediator.CreateStream, Test error propagation. Test Structure: tests/Synaxis.Tests/ containing Handlers/, Behaviors/, Execution/. Testing Tools: xUnit for test framework, NSubstitute or Moq for mocking, FluentAssertions for assertions. Coverage Target: \u003e80% line coverage for handlers, \u003e70% for behaviors, all public APIs tested. Estimated effort: 6-8 hours. Dependencies: Task 2.1 (Synaxis project created).","status":"closed","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:18.12789993+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:16:27.9778666+01:00","closed_at":"2026-02-08T15:16:27.9778666+01:00","close_reason":"All Epic 2 tasks completed successfully. Core implementation with Mediator integration, 3 provider packages (OpenAI, Azure, Anthropic), and comprehensive test suite (99 tests passing) all build with zero warnings.","dependencies":[{"issue_id":"Synaxis-67z","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:06.97173184+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-6rr","title":"Create Getting Started Guides for All Personas","description":"Objective: Create comprehensive getting started guides for the three main personas: Developers (using SDK), DevOps (deploying gateway), and SaaS Consumers (using cloud API). Each guide should take the user from zero to working code in 15 minutes. Persona 1 - Developer (SDK): docs/getting-started/quickstart-sdk.md - Install Synaxis NuGet package, Configure in ASP.NET Core app, Send first chat completion, Add streaming, Add multiple providers. Persona 2 - DevOps (Gateway): docs/getting-started/quickstart-server.md - Install Synaxis CLI, Configure providers, Start server, Test with curl, Deploy with Docker. Persona 3 - SaaS Consumer: docs/getting-started/quickstart-saas.md - Sign up for Synaxis Cloud, Get API key, Install Synaxis.Client, Send first request, Handle errors. Structure for Each Guide: Prerequisites, Installation, Configuration, First Request, Next Steps, Troubleshooting. Code Examples: Every step must have working code, Copy-paste runnable, Include error handling, Show output. Estimated effort: 6-8 hours for all three. Dependencies: All epics complete.","status":"open","priority":3,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:30:48.230394892+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:30:48.230394892+01:00","dependencies":[{"issue_id":"Synaxis-6rr","depends_on_id":"Synaxis-pdb","type":"blocks","created_at":"2026-02-08T14:31:17.830325862+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-6rr","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:11.614457956+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-6rr","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:11.662825653+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-6rr","depends_on_id":"Synaxis-a1r","type":"blocks","created_at":"2026-02-08T14:33:11.708465092+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-6rr","depends_on_id":"Synaxis-33p","type":"blocks","created_at":"2026-02-08T14:33:11.756313003+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-724","title":"Create ADR-012: SDK-First Package Architecture","description":"Objective: Write Architectural Decision Record 012 documenting the SDK-first package architecture, dependency rules, and versioning strategy. Context: This ADR explains why Synaxis uses a multi-tier package structure with strict dependency rules, and how it enables multiple consumption patterns (SDK, Gateway, SaaS). Content Requirements: Title: ADR-012: SDK-First Package Architecture. Status: Proposed (Accepted after review). Context: Synaxis must support multiple consumption patterns - Library (developers embed SDK), Gateway (DevOps deploy standalone), SaaS (customers use cloud API). Need clean architecture enabling all three without coupling. Decision: Create 4-tier package structure - Tier 1 Foundation (Synaxis.Abstractions, Synaxis.Contracts, optional Synaxis.Primitives) with zero deps, Tier 2 Core Implementation (Synaxis with Mediator, Synaxis.Providers.{Name} individual packages), Tier 3 Infrastructure (Synaxis.Client, Synaxis.Extensions.*), Tier 4 Transports \u0026 Adapters (Synaxis.Transport.*, Synaxis.Adapters.*), Tier 5 Server (Synaxis.Server thin composition). Dependency Rules: Abstractions never references Implementation, Contracts never references Implementation, Abstractions should not reference Contracts (avoid bidirectional), Contracts should not reference Abstractions (avoid bidirectional), if shared primitives needed create Synaxis.Primitives, all heavy deps go in Implementation or Adapters only. Unified Versioning: All first-party packages share same version (1.0.0, 1.1.0), breaking changes in Abstractions only on major versions. Consequences: Positive - clean separation, consumers pick only what they need, testable architecture, plugin architecture; Negative - more packages to manage, breaking changes affect entire ecosystem, steeper learning curve. File Location: docs/adr/012-sdk-first-package-architecture.md. Format: Follow existing ADR format (001-011). Review Process: Create as Proposed, review with team, mark Accepted when approved.","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:23.228853402+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.692796936+01:00","closed_at":"2026-02-08T14:15:48.692796936+01:00","close_reason":"Closed"}
{"id":"Synaxis-7fq","title":"Create ADR-015: Contracts Versioning Strategy","description":"Objective: Write Architectural Decision Record 015 documenting the namespace-based versioning strategy and stability tiers for contracts. Context: Synaxis.Contracts used by SDK consumers (compile-time, long-lived) and SaaS API (runtime, must evolve gracefully). Need strategy allowing evolution without breaking consumers. Content Requirements: Title: ADR-015: Contracts Versioning Strategy. Status: Proposed. Context: Contracts used by SDK (compile-time dependency) and SaaS (runtime wire format). Need evolution without breaking, N-1 compatibility, easy to understand. Decision: Use namespace-based versioning with stability tiers. Namespace Versioning: Synaxis.Contracts.V1.Messages for current, Synaxis.Contracts.V2.Messages for next version (breaking changes). Each major version gets own namespace, minor versions don't change namespace, breaking changes only in major versions (V1 -\u003e V2). Stability Tiers: Tier 1 Most Stable (Synaxis.Abstractions) - marker interfaces, core abstractions, breaking changes only on major versions (2.0, 3.0), goal never break. Tier 2 Stable (Synaxis.Contracts.V1) - message types, command interfaces, error types, breaking changes only on major versions, goal N-1 compatibility. Tier 3 Evolving (Synaxis.Contracts.V1+) - new optional properties, new message types, new commands, additive changes only no breaking changes, goal backward compatible within major version. Messages Namespace (Not DTOs): Data types in Messages namespace, not Dtos. Version Compatibility: Within major version (1.0 -\u003e 1.1) - can add new optional properties, add new message types, add new commands, cannot remove properties, change types, or change behavior. Major version bump (1.x -\u003e 2.0) - can make breaking changes, new namespace V2, old namespace remains available (deprecation period), consumers migrate gradually. N-1 Compatibility: Support current version (V1) and previous version (V0 deprecated). After releasing V2: support V2 (current), V1 (previous), drop V0. Deprecation timeline: 12 months or next major version whichever is longer. Error Handling Across Versions: Error codes and structure remain stable, new error codes can be added, old error codes never removed (only deprecated). Consequences: Positive - clear versioning, predictable breaking changes, N-1 compatibility reduces upgrade pressure, namespace makes version explicit; Negative - namespace clutter with multiple versions, migration complexity, more packages to maintain (V1, V2, etc.), IntelliSense pollution. Implementation Notes: Start with V1 no V0, plan for V2 within 12-18 months, use Obsolete attribute before removal, provide migration guides, automated API compatibility checking in CI. Related: ADR-012 (where contracts live), ADR-014 (version selection in DI). File: docs/adr/015-contracts-versioning-strategy.md.","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:07:11.69969305+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.703056011+01:00","closed_at":"2026-02-08T14:15:48.703056011+01:00","close_reason":"Closed"}
{"id":"Synaxis-8cc","title":"Archive Non-ADR Documentation","description":"Objective: Move all existing documentation from the docs/ directory (except the adr/ folder) and root-level markdown files to a dated archive location (docs/archive/2025-02-08/) using git mv to preserve file history. Background: The existing documentation was written for the previous monolithic InferenceGateway architecture and is no longer accurate for the SDK-first design, but contains valuable historical context that must be preserved. The docs/adr/ directory contains 11 approved ADRs (001-011) that remain relevant and must stay in place. Files to Archive - Root Level: README.md, AGENTS.md, IMPLEMENTATION_COMPLETE.md, IMPLEMENTATION_SUMMARY.md, TEST_COVERAGE_REPORT.md, BILLING_CACHE_IMPLEMENTATION.md. Files to Archive - docs/ Level: API.md, ARCHITECTURE.md, CONFIGURATION.md, CONTRIBUTING.md, COVERAGE_BASELINE.md, DEPLOYMENT.md, IDENTITY_API_KEY_IMPLEMENTATION.md, IMPLEMENTATION_COMPLETE.md, IMPLEMENTATION_SUMMARY.md, SECURITY.md, SYNAXIS_AGENTS_IMPLEMENTATION.md, TESTING.md, WEBSOCKET_REALTIME_UPDATES.md, workflows.md, 20260204-IMPLEMENTATION_SUMMARY.md, 20260204-TESTING.md. Directories to Archive: docs/plan/, docs/ops/, docs/reference/. Files to Preserve (DO NOT MOVE): docs/adr/README.md, docs/adr/001-stream-native-cqrs.md through docs/adr/011-dynamic-model-registry.md. Implementation: Use git mv to preserve history and blame information. Commands: mkdir -p docs/archive/2025-02-08 \u0026\u0026 git mv README.md docs/archive/2025-02-08/ \u0026\u0026 git mv AGENTS.md docs/archive/2025-02-08/ \u0026\u0026 git mv docs/API.md docs/archive/2025-02-08/ \u0026\u0026 ... (repeat for all files). Final commit: git commit -m 'docs: archive legacy documentation for SDK architecture transition - preserves ADRs 001-011'. Validation Checklist: After archival, running ls docs/ shows only 'adr/ archive/', running ls docs/adr/ shows all 11 ADR files plus README.md, running ls docs/archive/2025-02-08/ shows all archived files, git log shows descriptive commit, no build errors from missing documentation references. Decision Rationale: Use git mv over regular mv to preserve file history and blame information; this maintains audit trail and allows historical research. Risks: Breaking relative links in archived documents (mitigation: acceptable as archived docs are historical reference only), losing important documentation (mitigation: archiving preserves everything, nothing deleted), confusion about where current docs live (mitigation: new README will clarify SDK-first architecture).","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:05:09.56827315+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.669463971+01:00","closed_at":"2026-02-08T14:15:48.669463971+01:00","close_reason":"Closed"}
{"id":"Synaxis-8gs","title":"Create Runnable Sample Projects","description":"Objective: Create three working sample projects in samples/ directory that demonstrate real-world Synaxis usage. These samples serve as reference implementations and learning tools. Sample 1 - Minimal API: samples/MinimalApi/ - Single-file ASP.NET Core app using Synaxis SDK, Shows basic chat completion, Demonstrates dependency injection, Includes README with run instructions. Sample 2 - Self-Hosted Gateway: samples/SelfHosted/ - Full Synaxis.Server setup with Docker, Includes docker-compose.yml with PostgreSQL and Redis, Shows configuration via environment variables, Includes health checks and monitoring. Sample 3 - SaaS Client: samples/SaaSClient/ - Console app using Synaxis.Client, Shows typed client usage, Demonstrates streaming, Includes error handling and retries. Structure per Sample: README.md (what it is, how to run), Program.cs or Startup.cs (main code), appsettings.json (configuration), .csproj (project file), Dockerfile (if applicable). Quality Requirements: Each sample builds without warnings, Each sample runs without errors, Each sample has clear README, Code is well-commented. CI Integration: Add to CI pipeline to ensure samples always build. Estimated effort: 8-10 hours for all three. Dependencies: All epics complete.","status":"open","priority":3,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:30:54.171963631+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:30:54.171963631+01:00","dependencies":[{"issue_id":"Synaxis-8gs","depends_on_id":"Synaxis-pdb","type":"blocks","created_at":"2026-02-08T14:31:18.394989846+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-8gs","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:12.70711349+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-8gs","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:12.758914717+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-8gs","depends_on_id":"Synaxis-a1r","type":"blocks","created_at":"2026-02-08T14:33:12.805227699+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-8gs","depends_on_id":"Synaxis-33p","type":"blocks","created_at":"2026-02-08T14:33:12.858206921+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-9ph","title":"Create Synaxis.Adapters.Agents - Microsoft.Agents SDK Integration","description":"Objective: Create the Microsoft.Agents adapter for integration with Microsoft's agent framework (Bot Framework evolution). This enables Synaxis to participate in agent orchestration scenarios. Architecture: ActivityHandler implementation, Agent registration, Tool definitions for function calling, Conversation state management, Integration with ICommandExecutor. Project Structure: src/Synaxis.Adapters.Agents/ containing Handlers/MediatorActivityHandler.cs, Tools/ChatTool.cs, Tools/RoutingTool.cs, State/ConversationStateManager.cs, DependencyInjection/AgentsAdapterServiceCollectionExtensions.cs. Activity Handler: OnMessageActivityAsync processes incoming messages, creates ChatCommand, calls ICommandExecutor, sends response. Tool Implementation: ChatTool exposes chat completion as function, uses Function attribute, provides JSON schema. Configuration: public class AgentsAdapterOptions { public string AppId { get; set; } = string.Empty; public string AppPassword { get; set; } = string.Empty; public bool UseAuthentication { get; set; } = true; }. DI Registration: AddSynaxisAdapterAgents(). Testing: Unit tests for activity handler, Integration tests with Bot Framework emulator. Dependencies: Synaxis.Abstractions, Synaxis.Contracts, Synaxis, Microsoft.Agents. Estimated effort: 8-10 hours. Dependencies: Epic 1, Epic 2 complete.","status":"closed","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:32:07.075036212+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:24.918085067+01:00","closed_at":"2026-02-08T15:40:24.918085067+01:00","close_reason":"Transport and Adapter packages created successfully with zero warnings: HTTP (REST + SSE), gRPC (Protobuf), WebSocket, SignalR, and Microsoft.Agents adapters all build and implement proper abstractions.","dependencies":[{"issue_id":"Synaxis-9ph","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:09.550276248+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-a1r","title":"Transport Layer - HTTP, gRPC, and WebSocket Implementations","description":"Implements transport-specific packages that expose Synaxis functionality over different protocols. Each transport is a separate NuGet package that can be optionally consumed. All transports use ICommandExecutor and IStreamExecutor from Foundation, ensuring consistent behavior regardless of protocol. Scope: (1) Synaxis.Transport.Http - REST API with JSON, Server-Sent Events (SSE) for streaming, ASP.NET Core controllers, authentication middleware, OpenAPI/Swagger support. (2) Synaxis.Transport.Grpc - gRPC services with Protocol Buffers, server and client code generation, streaming support via gRPC server streaming, reflection service for debugging. (3) Synaxis.Transport.WebSocket - Raw WebSocket support for real-time bidirectional communication, frame handling, connection management. Key Design Pattern: All transports are thin adapters that deserialize requests into Commands, call ICommandExecutor/IStreamExecutor, serialize responses. No business logic in transports - pure protocol adaptation. Dependencies: Epic 1 (Foundation), Epic 2 (Core Implementation - need handlers to execute). Success Criteria: All three transport packages build with zero warnings, HTTP transport handles REST and SSE correctly, gRPC transport handles unary and streaming calls, WebSocket transport handles frames, Each transport has explicit DI registration (AddSynaxisTransport*), Each transport has endpoint mapping (MapSynaxisTransport*), Integration tests prove end-to-end functionality. Risks: Protocol differences cause inconsistent behavior (mitigation: all use same executor), Performance differences between transports (mitigation: document and benchmark), WebSocket complexity (mitigation: well-tested frame handling).","status":"closed","priority":2,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:40.231455243+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:35.013704312+01:00","closed_at":"2026-02-08T15:40:35.013704312+01:00","close_reason":"All child tasks completed successfully. Epic 3: HTTP, gRPC, WebSocket transports with zero warnings. Epic 4: SignalR, Agents, MCP adapters with zero warnings."}
{"id":"Synaxis-ajl","title":"Create ADR-013: Transport Abstraction with Mediator","description":"Objective: Write Architectural Decision Record 013 documenting the use of MartinOthamar.Mediator for CQRS and the transport abstraction pattern. Context: Synaxis must support HTTP, gRPC, WebSocket, SignalR, Microsoft.Agents, MCP - all with same business logic. Need clean abstraction to avoid duplication. Content Requirements: Title: ADR-013: Transport Abstraction with Mediator. Status: Proposed. Context: Multiple transport protocols needed (HTTP/REST for compatibility, gRPC for performance, WebSocket for real-time, SignalR for .NET, Agents for orchestration, MCP for protocol). All must share same business logic. Decision: Use MartinOthamar.Mediator as CQRS backbone with clean transport abstractions. Architecture: Transport Layer (REST, gRPC, SignalR, Agents, MCP) -\u003e Abstraction Layer (ICommandExecutor, IStreamExecutor) -\u003e Mediator Layer (Commands -\u003e Handlers -\u003e Behaviors) -\u003e Business Logic (Routing, Provider Selection). Key Abstractions: ICommandExecutor.ExecuteAsync{TCommand, TResponse} with ValueTask, IStreamExecutor.StreamAsync{TCommand, TResponse} with IAsyncEnumerable. Pattern: Commands implement ICommand{TResponse}, Handlers implement Mediator's IRequestHandler, Streaming uses IStreamRequest{T} and IAsyncEnumerable, Transports delegate to ICommandExecutor/IStreamExecutor, Business logic lives in Handlers never in transports. Transport-Specific Code Location: Only in adapter packages, never in business logic. Consequences: Positive - single business logic implementation, easy to add new transports, testable, Mediator is source-generated zero reflection; Negative - learning curve for Mediator, requires understanding source generators, IAsyncEnumerable limitations in some transports, harder debugging with pipelines. Related: ADR-012 (package structure enables this), ADR-014 (DI registration). File: docs/adr/013-transport-abstraction-mediator.md.","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:31.550760485+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.696026497+01:00","closed_at":"2026-02-08T14:15:48.696026497+01:00","close_reason":"Closed"}
{"id":"Synaxis-amw","title":"Create Synaxis.Providers.Anthropic Package - Claude API Integration","description":"Objective: Create the Anthropic provider package for Claude API integration. Context: Anthropic's Claude models are popular for their safety features and long context windows. Synaxis must support Claude as a first-class provider. API Differences: Different message format (messages array but different structure), Supports system prompts differently, Streaming format differs from OpenAI, Unique features like constitutional AI. Implementation: Implement IChatProvider for Claude, Handle Anthropic-specific message formatting, Support streaming with their SSE format, Map errors appropriately. Project Structure: src/Synaxis.Providers.Anthropic/ containing AnthropicChatProvider.cs, AnthropicClient.cs, Configuration/AnthropicOptions.cs, DependencyInjection/AnthropicProviderExtensions.cs. Authentication: Header x-api-key: {apiKey}, Optional anthropic-version header. Endpoints: POST /v1/messages (chat completions), POST /v1/messages (streaming). Message Format: {model: 'claude-3-opus-20240229', messages: [{role: 'user', content: 'Hello'}], max_tokens: 1024}. Estimated effort: 4-6 hours. Dependencies: Epic 1 complete.","status":"closed","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:15.780844526+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:16:27.974304737+01:00","closed_at":"2026-02-08T15:16:27.974304737+01:00","close_reason":"All Epic 2 tasks completed successfully. Core implementation with Mediator integration, 3 provider packages (OpenAI, Azure, Anthropic), and comprehensive test suite (99 tests passing) all build with zero warnings.","dependencies":[{"issue_id":"Synaxis-amw","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:06.9246826+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-bvl","title":"Fix IntegrationTests CS compilation errors (API breaking changes)","status":"in_progress","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-07T22:52:20.872248053+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T22:52:25.269788664+01:00"}
{"id":"Synaxis-d37","title":"Create Integration Tests for All Transport Implementations","description":"Objective: Create comprehensive integration tests for HTTP, gRPC, and WebSocket transports using Testcontainers and WebApplicationFactory. Context: Integration tests verify that transports correctly interact with the core Synaxis implementation, properly serialize/deserialize requests, handle errors, and support streaming. Testing Approach: Use WebApplicationFactory to host Synaxis with specific transport, Use Testcontainers for real PostgreSQL and Redis, Mock external providers (OpenAI, etc.), Test complete request/response cycles. Test Categories: HTTP Transport Tests - POST /v1/chat/completions returns 200 with valid JSON, POST with streaming returns SSE format, Invalid requests return 400. gRPC Transport Tests - Unary call returns protobuf response, Streaming call returns multiple messages, Error handling returns proper gRPC status codes. WebSocket Transport Tests - Connection upgrade succeeds, Command message returns response message, Streaming sends multiple messages. Project Structure: tests/Synaxis.Transport.IntegrationTests/ containing Http/, Grpc/, WebSocket/, Fixtures/SynaxisWebApplicationFactory.cs. Coverage Target: All transport endpoints tested, All error paths tested, Streaming functionality verified, \u003e70% line coverage. Estimated effort: 8-10 hours. Dependencies: Tasks 3.1, 3.2, 3.3 complete.","status":"open","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:42.638886084+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:31:42.638886084+01:00","dependencies":[{"issue_id":"Synaxis-d37","depends_on_id":"Synaxis-qpa","type":"blocks","created_at":"2026-02-08T14:33:08.527065202+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-d37","depends_on_id":"Synaxis-0zv","type":"blocks","created_at":"2026-02-08T14:33:08.576728102+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-d37","depends_on_id":"Synaxis-hqr","type":"blocks","created_at":"2026-02-08T14:33:08.626308103+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-d9k","title":"Fix SA1018 nullable type spacing errors in Infrastructure project","status":"open","priority":2,"issue_type":"bug","owner":"rudimar@outlook.com","created_at":"2026-02-07T21:49:46.007315158+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T21:49:46.007315158+01:00"}
{"id":"Synaxis-dnl","title":"Create Individual README.md Files for All Packages","description":"Objective: Create README.md files for each NuGet package in the repository. These appear on NuGet.org and provide package-specific documentation. Packages Requiring READMEs: src/Synaxis.Abstractions/README.md, src/Synaxis.Contracts/README.md, src/Synaxis/README.md, src/Synaxis.Client/README.md, src/Synaxis.Transport.Http/README.md, src/Synaxis.Transport.Grpc/README.md, src/Synaxis.Transport.WebSocket/README.md, src/Synaxis.Adapters.SignalR/README.md, src/Synaxis.Adapters.Agents/README.md, src/Synaxis.Adapters.Mcp/README.md, src/Synaxis.Server/README.md. Content per README: Package name and description, When to use this package, Installation command (dotnet add package), Quick usage example, Link to full documentation, Dependencies (what it references). Quality Requirements: Each README is concise but complete, Each has working code example, Links work correctly. Estimated effort: 4-6 hours for all packages. Dependencies: All epics complete.","status":"open","priority":3,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:11.285608634+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:31:11.285608634+01:00","dependencies":[{"issue_id":"Synaxis-dnl","depends_on_id":"Synaxis-pdb","type":"blocks","created_at":"2026-02-08T14:31:20.134141319+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-dnl","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:14.609252981+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-dnl","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:14.657568834+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-dnl","depends_on_id":"Synaxis-a1r","type":"blocks","created_at":"2026-02-08T14:33:14.706224107+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-dnl","depends_on_id":"Synaxis-33p","type":"blocks","created_at":"2026-02-08T14:33:14.758878823+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-e0b","title":"Create Synaxis Project - Core Implementation with Mediator Integration","description":"Objective: Create the Synaxis project implementing the core SDK functionality with Mediator-based CQRS. This is the main implementation package that references Foundation (Abstractions and Contracts) and provides concrete command handlers, pipeline behaviors, and execution implementations. Architecture: Commands/ (concrete command records that implement contract interfaces - ChatCommand implements IChatCommand), Handlers/ (Mediator request handlers - ChatCommandHandler implements IRequestHandler{ChatCommand, ChatResponse}), Behaviors/ (cross-cutting concerns via Mediator pipeline - LoggingBehavior, ValidationBehavior, etc.), Execution/ (ICommandExecutor and IStreamExecutor implementations that delegate to Mediator), Routing/ (provider selection strategies), Infrastructure/ (persistence, caching, external service clients). Key Implementation Details: Commands are records with init-only properties, Handlers receive dependencies via constructor injection, Behaviors wrap handler execution for cross-cutting concerns, Executor implementations use IMediator.Send() and IMediator.CreateStream(). Project Structure: src/Synaxis/ containing Commands/, Handlers/, Behaviors/, Execution/, Routing/, DependencyInjection/ServiceCollectionExtensions.cs (AddSynaxis()). Dependencies: PackageReferences: Synaxis.Abstractions, Synaxis.Contracts, MartinOthamar.Mediator, Microsoft.Extensions.Logging, Microsoft.Extensions.DependencyInjection. Project Configuration: TargetFramework net10.0, Nullable enable, TreatWarningsAsErrors true. Build Validation: dotnet build succeeds with zero warnings, can reference Synaxis.Abstractions and Synaxis.Contracts, Mediator source generators run successfully. Estimated effort: 8-12 hours. Dependencies: Epic 1 (Foundation) complete. Blocks: Task 2.2 (Tests), Epic 3 (Transports), Epic 4 (Adapters).","status":"closed","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:06.192225292+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:16:27.963291151+01:00","closed_at":"2026-02-08T15:16:27.963291151+01:00","close_reason":"All Epic 2 tasks completed successfully. Core implementation with Mediator integration, 3 provider packages (OpenAI, Azure, Anthropic), and comprehensive test suite (99 tests passing) all build with zero warnings.","dependencies":[{"issue_id":"Synaxis-e0b","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:06.780224402+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-eeg","title":"Fix failing Infrastructure.Tests","notes":"Infrastructure.Tests builds successfully (0 errors) after analyzer fixes, but 26 tests are failing:\n\nCategories of failures:\n1. SoftDeleteInterceptorTests (13 failures) - Database entities not being soft-deleted properly\n2. ControlPlaneExtensionsTests (4 failures) - Missing ILogger\u003cControlPlaneDbContext\u003e registration\n3. SecurityConfigurationValidatorTests (4 failures) - Weak secret validation logic issues\n4. ApiKeyServiceTests (2 failures) - Error message text mismatches\n5. TenantResolutionMiddlewareTests (1 failure) - Mock verification issue\n6. IdentityManagerTests (1 failure) - Null token issue\n7. CopilotSdkClientTests (1 failure) - Dispose not called\n\nThese are pre-existing test failures unrelated to the analyzer fixes.\nBuild:  (0 errors, 0 warnings)\nTests:  (26 failures)","status":"open","priority":2,"issue_type":"bug","owner":"rudimar@outlook.com","created_at":"2026-02-07T22:21:34.383671581+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-07T22:21:43.572854752+01:00"}
{"id":"Synaxis-g77","title":"Create Root README.md - Project Overview and Quick Start","description":"Objective: Create the main README.md file at repository root that serves as the entry point for Synaxis. This is the first thing visitors see and must clearly communicate what Synaxis is, why it exists, and how to get started. Structure: Title and Tagline (Synaxis - Enterprise AI Gateway SDK), Badges (build status, NuGet version, license), One-paragraph description (what is it), Key Features (SDK-first, multi-transport, provider-agnostic), Quick Start (3 code examples: SDK usage, Self-hosted, SaaS), Installation (NuGet commands), Usage Examples, Architecture Overview (link to docs), Contributing (link to CONTRIBUTING.md), License. Content Requirements: Clear value proposition (why Synaxis vs alternatives), Code examples must be copy-paste runnable, Link to full documentation, Visual diagram of architecture. Writing Style: Professional but approachable, Code-first (show don't tell), Clear headings and sections. Estimated effort: 3-4 hours. Dependencies: All epics complete (need stable APIs to document).","status":"open","priority":3,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:30:41.671228873+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:30:41.671228873+01:00","dependencies":[{"issue_id":"Synaxis-g77","depends_on_id":"Synaxis-pdb","type":"blocks","created_at":"2026-02-08T14:31:17.200622328+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-g77","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:10.702826383+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-g77","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:10.757397589+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-g77","depends_on_id":"Synaxis-a1r","type":"blocks","created_at":"2026-02-08T14:33:10.807665723+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-g77","depends_on_id":"Synaxis-33p","type":"blocks","created_at":"2026-02-08T14:33:10.856547495+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-gvj","title":"Create Synaxis.Providers.OpenAI Package - OpenAI API Integration","description":"Objective: Create the OpenAI provider package implementing IChatProvider, IEmbeddingProvider, and other capability interfaces for OpenAI's API (GPT-4, GPT-3.5, DALL-E, Whisper, etc.). Architecture: Implements provider interfaces from Synaxis.Abstractions, uses HttpClient for API calls, supports both standard and streaming endpoints, handles authentication via API key, implements rate limiting and retry logic, maps OpenAI-specific formats to Synaxis contracts. Project Structure: src/Synaxis.Providers.OpenAI/ containing OpenAIChatProvider.cs (implements IChatProvider), OpenAIEmbeddingProvider.cs, OpenAIImageProvider.cs, OpenAIAudioProvider.cs, OpenAIClient.cs, Configuration/OpenAIOptions.cs, DependencyInjection/OpenAIProviderExtensions.cs. Implementation Details: Authentication via Authorization: Bearer {apiKey} header, Endpoints: /v1/chat/completions, /v1/embeddings, /v1/images/generations, /v1/audio/transcriptions, Request/Response mapping between OpenAI and Synaxis formats, Error handling for rate limits (429), auth failures (401). Testing: Unit tests with mocked HttpClient, Integration tests with real API (optional). Estimated effort: 6-8 hours. Dependencies: Epic 1 complete, Task 2.1 started.","status":"closed","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:09.706779561+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:16:27.967267178+01:00","closed_at":"2026-02-08T15:16:27.967267178+01:00","close_reason":"All Epic 2 tasks completed successfully. Core implementation with Mediator integration, 3 provider packages (OpenAI, Azure, Anthropic), and comprehensive test suite (99 tests passing) all build with zero warnings.","dependencies":[{"issue_id":"Synaxis-gvj","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:06.830059422+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-hqr","title":"Create Synaxis.Transport.WebSocket Package - Real-Time Bidirectional Communication","description":"Objective: Create the WebSocket transport package for scenarios requiring full-duplex communication with lower overhead than HTTP polling. Architecture: ASP.NET Core WebSocket middleware, Frame handling (text and binary), Connection management, Message serialization (JSON), Integration with ICommandExecutor and IStreamExecutor. Project Structure: src/Synaxis.Transport.WebSocket/ containing Middleware/WebSocketMiddleware.cs, Handlers/WebSocketHandler.cs, Protocol/WebSocketMessage.cs, Protocol/MessageSerializer.cs, DependencyInjection/WebSocketTransportServiceCollectionExtensions.cs. Protocol: WebSocket messages are JSON with envelope { 'type': 'command', 'commandType': 'ChatCommand', 'payload': { ... } }. Streaming responses sent as multiple WebSocket messages. Middleware: Handles upgrade, connection lifecycle, message routing. Configuration: public class WebSocketTransportOptions { public string Path { get; set; } = '/ws'; public int ReceiveBufferSize { get; set; } = 1024 * 4; public TimeSpan KeepAliveInterval { get; set; } = TimeSpan.FromSeconds(30); }. DI Registration: AddSynaxisTransportWebSocket(), UseSynaxisTransportWebSocket(). Testing: Unit tests for message serialization, Integration tests with WebSocket client, Connection lifecycle tests. Dependencies: Synaxis.Abstractions, Synaxis.Contracts, Synaxis. Estimated effort: 6-8 hours. Dependencies: Epic 1, Epic 2 complete.","status":"closed","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:39.618666706+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:24.898169664+01:00","closed_at":"2026-02-08T15:40:24.898169664+01:00","close_reason":"Transport and Adapter packages created successfully with zero warnings: HTTP (REST + SSE), gRPC (Protobuf), WebSocket, SignalR, and Microsoft.Agents adapters all build and implement proper abstractions.","dependencies":[{"issue_id":"Synaxis-hqr","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:07.804858708+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-iui","title":"Create Synaxis.Contracts Project - Versioned Data Contracts with Messages Namespace","description":"Objective: Create the data contracts package that defines versioned data shapes for Synaxis SDK, using Messages namespace (not DTOs) under V1 versioning. Context: This package is consumed by both SDK users (compile-time dependency) and SaaS API (runtime wire format). Contracts must be stable, versioned, and designed for evolution. Critical Design Decisions: (1) Messages Namespace (Not DTOs) - Choice: Use Synaxis.Contracts.V1.Messages namespace instead of Dtos. Rationale: DTO (Data Transfer Object) is an implementation detail implying serialization, Messages conveys semantic meaning (these are the messages passed between components). Alternative Considered: Dtos, Types, Data. Rejected Because: Messages is semantic and clear, DTOs implies anemic objects, Types is too generic, Data is ambiguous. (2) Versioned with V1 Namespace - Choice: Synaxis.Contracts.V1.Messages for current version. Rationale: Namespace-based versioning allows multiple versions to coexist, enables gradual migration, makes version explicit in code. Future versions: Synaxis.Contracts.V2.Messages. Breaking changes only in major versions (V1 -\u003e V2). (3) Records for Immutability - Choice: Use C# 9.0 records for all message types. Rationale: Records provide value semantics, immutability by default, concise syntax, built-in equality/hashing, pattern matching support. Example: public record ChatMessage(string Role, string Content); (4) Init-Only Properties - Choice: Use init-only properties for flexibility within immutability. Rationale: Allows object initializer syntax while maintaining immutability after construction. Syntax: public string Model { get; init; } = string.Empty; (5) Nullability Annotations - Choice: Enable nullable reference types with full annotation. Rationale: Compile-time null safety, better IntelliSense, documents nullability contract. Pattern: Required properties are non-nullable (string), optional properties are nullable (string?). (6) XML Documentation - Choice: Require XML documentation on all public types. Rationale: Foundation for IntelliSense, enables GenerateDocumentationFile, professional API surface. Directory Structure: src/Synaxis.Contracts/ containing V1/ directory with Messages/ (ChatMessage.cs, ChatResponse.cs, ChatStreamChunk.cs, EmbeddingRequest.cs, EmbeddingResponse.cs, ImageGenerationRequest.cs, ImageGenerationResponse.cs, AudioTranscriptionRequest.cs, AudioTranscriptionResponse.cs, RerankRequest.cs, RerankResponse.cs, BatchRequest.cs, BatchResponse.cs, UsageInfo.cs), Commands/ (IChatCommand.cs, IChatStreamCommand.cs, IEmbeddingCommand.cs, IImageGenerationCommand.cs, IAudioTranscriptionCommand.cs, IRerankCommand.cs, ICreateBatchCommand.cs, ICancelBatchCommand.cs), Auth/ (IAuthenticationContext.cs, IApiKeyCredential.cs), Errors/ (SynaxisError.cs, ErrorSeverity.cs, ErrorCategory.cs, IErrorResponse.cs). Key Implementation Details: ChatMessage is record with Role, Content, optional Name, ChatResponse has Id, Object, Created, Model, Message, Usage, SystemFingerprint, UsageInfo has PromptTokens, CompletionTokens, TotalTokens, SynaxisError has Code, Message, Severity, Category, Details, IChatCommand implements Abstractions.ICommand{ChatResponse} with Model, Messages, Temperature, MaxTokens, UserId, OrganizationId, TenantId. Project File: References Synaxis.Abstractions only, TargetFramework netstandard2.1, Nullable enable, TreatWarningsAsErrors true, GenerateDocumentationFile true, PackageId Synaxis.Contracts, Version 0.1.0-alpha. Build Validation: dotnet build succeeds with zero warnings, references only Synaxis.Abstractions, can be packed to NuGet. Acceptance Criteria: Project builds with zero warnings, references only Abstractions package, all contracts use Messages namespace (not Dtos), all contracts versioned under V1 namespace, records used for all message types, init-only properties for optional fields, nullability annotations throughout, XML documentation on all public types. Risks: Versioning strategy doesn't account for all scenarios (mitigation: ADR-015 defines comprehensive strategy), namespace naming causes confusion (mitigation: consistent V1.Messages pattern, documented in ADR-015).","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:05:50.74873526+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.679891197+01:00","closed_at":"2026-02-08T14:15:48.679891197+01:00","close_reason":"Closed"}
{"id":"Synaxis-k4o","title":"Archive Legacy Documentation While Preserving Architectural Decision Records","description":"Objective: Move all existing documentation from the docs/ directory (except the adr/ folder) and root-level markdown files to a dated archive location (docs/archive/2025-02-08/) using git mv to preserve file history. Background: The existing documentation was written for the previous monolithic InferenceGateway architecture and is no longer accurate for the SDK-first design, but contains valuable historical context that must be preserved. The docs/adr/ directory contains 11 approved ADRs (001-011) that remain relevant and must stay in place. Files to Archive - Root Level: README.md, AGENTS.md, IMPLEMENTATION_COMPLETE.md, IMPLEMENTATION_SUMMARY.md, TEST_COVERAGE_REPORT.md, BILLING_CACHE_IMPLEMENTATION.md. Files to Archive - docs/ Level: API.md, ARCHITECTURE.md, CONFIGURATION.md, CONTRIBUTING.md, COVERAGE_BASELINE.md, DEPLOYMENT.md, IDENTITY_API_KEY_IMPLEMENTATION.md, IMPLEMENTATION_COMPLETE.md, IMPLEMENTATION_SUMMARY.md, SECURITY.md, SYNAXIS_AGENTS_IMPLEMENTATION.md, TESTING.md, WEBSOCKET_REALTIME_UPDATES.md, workflows.md, 20260204-IMPLEMENTATION_SUMMARY.md, 20260204-TESTING.md. Directories to Archive: docs/plan/, docs/ops/, docs/reference/. Files to Preserve (DO NOT MOVE): docs/adr/README.md, docs/adr/001-stream-native-cqrs.md through docs/adr/011-dynamic-model-registry.md. Implementation: Use git mv to preserve history and blame information. Commands: mkdir -p docs/archive/2025-02-08 \u0026\u0026 git mv README.md docs/archive/2025-02-08/ \u0026\u0026 git mv AGENTS.md docs/archive/2025-02-08/ \u0026\u0026 git mv docs/API.md docs/archive/2025-02-08/ \u0026\u0026 ... (repeat for all files). Final commit: git commit -m 'docs: archive legacy documentation for SDK architecture transition - preserves ADRs 001-011'. Validation: After archival, running ls docs/ shows only 'adr/ archive/', running ls docs/adr/ shows all 11 ADR files plus README.md, running ls docs/archive/2025-02-08/ shows all archived files, git log shows descriptive commit, no build errors. Estimated effort: 30 minutes. Dependencies: None. Blocks: Task 1.6 (Create new ADRs 012-015).","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:32:16.163305296+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:00:43.291127485+01:00","closed_at":"2026-02-08T15:00:43.291127485+01:00","close_reason":"Successfully archived all legacy documentation to docs/archive/2025-02-08/. Preserved ADRs 001-011 in docs/adr/. Git history maintained via git mv."}
{"id":"Synaxis-kfq","title":"Update docs/adr/README.md to Include New ADRs","description":"Objective: Update the Architectural Decision Records index file to include links and summaries for ADRs 012-015. Context: The existing docs/adr/README.md contains index for ADRs 001-011. We need to add the new ADRs created in this project. Content to Add: ADR-012: SDK-First Package Architecture - Multi-tier package structure with strict dependency rules, ADR-013: Transport Abstraction with Mediator - Using Mediator for CQRS across all transports, ADR-014: Explicit Registration Pattern - No auto-discovery, explicit DI registration only, ADR-015: Contracts Versioning Strategy - Namespace-based versioning with stability tiers. Format: Follow existing format in docs/adr/README.md (likely table or list with ADR number, title, status, brief description). Also ensure the new ADRs are linked properly. Estimated effort: 30 minutes. Dependencies: Tasks 1.6-1.9 complete (ADRs created).","status":"open","priority":3,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:05.706612045+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:31:05.706612045+01:00","dependencies":[{"issue_id":"Synaxis-kfq","depends_on_id":"Synaxis-pdb","type":"blocks","created_at":"2026-02-08T14:31:19.49217073+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-kfq","depends_on_id":"Synaxis-k4o","type":"blocks","created_at":"2026-02-08T14:33:05.536276583+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-kfq","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:15.626928243+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-kfq","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:15.680208496+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-kfq","depends_on_id":"Synaxis-a1r","type":"blocks","created_at":"2026-02-08T14:33:15.726096721+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-kfq","depends_on_id":"Synaxis-33p","type":"blocks","created_at":"2026-02-08T14:33:15.774031499+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-p3j","title":"Create Synaxis.Adapters.Mcp - Model Context Protocol Implementation","description":"Objective: Create the Model Context Protocol (MCP) adapter for standardized tool and resource sharing. MCP allows Synaxis to expose its capabilities (chat, embeddings, etc.) as tools that any MCP-compatible client can use. Architecture: MCP server implementation, Tool definitions, Resource providers, Prompt templates, Multiple transport support (stdio, HTTP, SSE). Project Structure: src/Synaxis.Adapters.Mcp/ containing Server/SynaxisMcpServer.cs, Tools/ChatCompletionTool.cs, Tools/EmbeddingTool.cs, Resources/ModelResourceProvider.cs, Prompts/SystemPromptProvider.cs, Transports/StdioTransport.cs, Transports/HttpTransport.cs, Transports/SseTransport.cs, DependencyInjection/McpAdapterServiceCollectionExtensions.cs. Server Implementation: SynaxisMcpServer extends McpServer, registers tools in ConfigureTools. Tool Definition: ChatCompletionTool implements IMcpTool, provides JSON schema for parameters, ExecuteAsync delegates to ICommandExecutor. Transport Support: StdioTransport for CLI tools, HttpTransport for web clients, SseTransport for server-sent events. Configuration: public class McpAdapterOptions { public string ServerName { get; set; } = 'synaxis'; public string ServerVersion { get; set; } = '1.0.0'; public McpTransportType DefaultTransport { get; set; } = McpTransportType.Stdio; }. Testing: Unit tests for tools, Integration tests with MCP client. Dependencies: Synaxis.Abstractions, Synaxis.Contracts, Synaxis, ModelContextProtocol SDK. Estimated effort: 8-10 hours. Dependencies: Epic 1, Epic 2 complete.","status":"closed","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:32:10.816454289+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:33.272030243+01:00","closed_at":"2026-02-08T15:40:33.272030243+01:00","close_reason":"MCP adapter created successfully with zero warnings. Implements Model Context Protocol with tools, resources, and prompts. All types properly separated into individual files per SA1649.","dependencies":[{"issue_id":"Synaxis-p3j","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:09.607593785+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-pdb","title":"Documentation \u0026 Samples - Complete SDK Documentation and Working Examples","description":"Creates comprehensive documentation and working sample projects that demonstrate how to consume Synaxis in different scenarios. Documentation must be clear enough for developers, DevOps, and SaaS consumers to understand their specific use cases. Samples must be runnable and demonstrate best practices. Scope: (1) Documentation - README.md (project overview), docs/getting-started/ (quickstart guides for different personas), docs/architecture/ (deep dives), docs/packages/ (per-package documentation), docs/api/ (API reference). (2) Sample Projects - Minimal API example, Self-hosted server example, SaaS client example, Microservices example. Success Criteria: New user can get started in 5 minutes, All samples build and run without errors, Architecture decisions are clearly explained, API documentation covers all public types, Contributing guidelines are clear. Dependencies: All previous epics complete (need stable APIs to document). Risks: Documentation becomes outdated (mitigation: automate API doc generation), Samples don't work (mitigation: CI tests for samples).","status":"open","priority":3,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:30:30.634991735+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:30:30.634991735+01:00"}
{"id":"Synaxis-qpa","title":"Create Synaxis.Transport.Http Package - REST API with JSON and Server-Sent Events","description":"Objective: Create the HTTP transport package implementing REST API with JSON serialization and Server-Sent Events (SSE) for streaming. This is the primary transport for broad compatibility with existing HTTP clients and OpenAI SDK compatibility. Architecture: ASP.NET Core controllers for request handling, JSON serialization with System.Text.Json, SSE for streaming responses, middleware for authentication and correlation IDs, OpenAPI/Swagger for documentation. Project Structure: src/Synaxis.Transport.Http/ containing Controllers/ChatController.cs (POST /v1/chat/completions, supports streaming), Controllers/EmbeddingsController.cs, Controllers/ModelsController.cs, Filters/SynaxisExceptionFilter.cs, Middleware/CorrelationIdMiddleware.cs, Mapping/RequestMapper.cs, DependencyInjection/HttpTransportServiceCollectionExtensions.cs. Key Implementation: ChatController has two actions - non-streaming returning ChatResponse, streaming with [Produces('text/event-stream')] returning IAsyncEnumerable{ChatStreamChunk}. SSE Format: data: {json}\\n\\n for each chunk, data: [DONE]\\n\\n when complete. Configuration: public class HttpTransportOptions { public bool RequireAuthentication { get; set; } = true; public bool EnableStreaming { get; set; } = true; public long MaxRequestBodySize { get; set; } = 10 * 1024 * 1024; }. DI Registration: AddSynaxisTransportHttp(), UseSynaxisTransportHttp(), MapSynaxisTransportHttp(). Testing: Unit tests for controllers with mocked executor, Integration tests for end-to-end HTTP calls. Estimated effort: 8-10 hours. Dependencies: Epic 1, Epic 2 complete.","status":"closed","priority":2,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:32.777838779+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:40:24.877613749+01:00","closed_at":"2026-02-08T15:40:24.877613749+01:00","close_reason":"Transport and Adapter packages created successfully with zero warnings: HTTP (REST + SSE), gRPC (Protobuf), WebSocket, SignalR, and Microsoft.Agents adapters all build and implement proper abstractions.","dependencies":[{"issue_id":"Synaxis-qpa","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:07.694183489+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-r48","title":"Fix analyzer errors in OpenAI provider package","status":"closed","priority":1,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T15:08:17.78300139+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:14:08.20772767+01:00","closed_at":"2026-02-08T15:14:08.20772767+01:00","close_reason":"Successfully fixed all 38 analyzer errors - split models into separate files, refactored OpenAIClient, fixed exception handling, and removed unused loggers"}
{"id":"Synaxis-r4j","title":"Create ADR-014: Explicit Registration Pattern","description":"Objective: Write Architectural Decision Record 014 documenting the explicit DI registration pattern and prohibition of auto-discovery. Context: Synaxis has many optional components (transports, adapters, providers) and needs predictable, discoverable configuration without runtime surprises. Content Requirements: Title: ADR-014: Explicit Registration Pattern. Status: Proposed. Context: Many optional components, need explicit and predictable configuration, easy to debug, self-documenting. Auto-discovery causes runtime surprises. Decision: Use explicit DI registration only, NO auto-discovery, NO assembly scanning. Registration Pattern: services.AddSynaxis() for core, services.AddSynaxisTransportHttp() for HTTP, services.AddSynaxisTransportGrpc() for gRPC, services.AddSynaxisAdapterSignalR() for SignalR, app.MapSynaxisTransportHttp() for endpoint mapping. Naming Convention: Core uses AddSynaxis(), Transports use AddSynaxisTransport{Name}(), Adapters use AddSynaxisAdapter{Name}(), Providers use Add{ProviderName}Provider() inside options, Mapping uses MapSynaxisTransport{Name}() and MapSynaxisAdapter{Name}(). Per-Package Registration: Each package provides its own extensions, no central registration. Registration Order: 1. Core (AddSynaxis), 2. Transports (AddSynaxisTransport*), 3. Adapters (AddSynaxisAdapter*), 4. Use middleware (UseSynaxisTransport*), 5. Map endpoints (MapSynaxis*). What NOT to Do: No AddSynaxisAll(), no assembly scanning, no automatic transport registration, no convention-based configuration. Consequences: Positive - explicit and predictable, IntelliSense shows options, no runtime surprises, clear dependency graph, easy to debug; Negative - more verbose setup, must document registration order, easy to forget Map* methods, breaking changes require updating registration code. Implementation Notes: Use IOptions{T} pattern, validate at startup (fail fast), meaningful error messages if order wrong, consider source generators for validation. Related: ADR-012 (package structure), ADR-013 (what gets registered). File: docs/adr/014-explicit-registration-pattern.md.","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:58.233933867+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.699441607+01:00","closed_at":"2026-02-08T14:15:48.699441607+01:00","close_reason":"Closed"}
{"id":"Synaxis-v49","title":"Create Comprehensive Test Suite for Synaxis.Abstractions","description":"Objective: Create unit test project for Synaxis.Abstractions with comprehensive coverage of interfaces, marker types, and compilation verification. Context: While Abstractions contains only interfaces and no implementation logic, tests are critical to verify: (1) Interfaces can be implemented by external code, (2) Generic constraints work as expected, (3) Covariance/contravariance behaves correctly, (4) Nullability annotations are correct, (5) Project references and builds work. Test Strategy: (1) Compilation Tests - Verify Abstractions project compiles with zero warnings and zero errors, Verify zero external dependencies, Verify correct target framework. (2) Implementation Tests - Create test implementations of each interface to verify they can be implemented, Verify generic constraints are satisfiable, Verify covariance works (can assign ICommand{string} to ICommand{object}). (3) Contract Tests - Verify marker interfaces are truly empty, Verify async method signatures are correct, Verify CancellationToken parameters exist. Directory Structure: tests/Synaxis.Abstractions.Tests/ containing CompilationTests.cs (Build_Succeeds_With_Zero_Warnings, Has_Zero_External_Dependencies, Targets_NetStandard_2_1), InterfaceImplementationTests.cs (ICommand_Can_Be_Implemented, IStreamRequest_Can_Be_Implemented, ICommandExecutor_Can_Be_Implemented, IStreamExecutor_Can_Be_Implemented, IProviderClient_Can_Be_Implemented, Covariance_Works_For_Commands), MarkerInterfaceTests.cs (ICommand_Is_Empty_Marker, IStreamRequest_Is_Empty_Marker, INotification_Is_Empty_Marker). Test Examples: [Fact] public void ICommand_Can_Be_Implemented() { var command = new TestCommand(); Assert.IsAssignableFrom{ICommand{string}}(command); } private record TestCommand : ICommand{string} { }. Project File: Tests/Synaxis.Abstractions.Tests.csproj references Synaxis.Abstractions, uses xUnit, FluentAssertions, Microsoft.NET.Test.Sdk. Coverage Target: 100% of public API surface (interfaces must be implementable). Acceptance Criteria: All tests pass, 100% compilation success rate, zero test warnings, interfaces proven implementable, covariance verified.","status":"closed","priority":0,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:06:04.17453693+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:15:48.686103589+01:00","closed_at":"2026-02-08T14:15:48.686103589+01:00","close_reason":"Closed"}
{"id":"Synaxis-wfk","title":"Create Comprehensive Architecture Documentation","description":"Objective: Create in-depth architecture documentation explaining Synaxis design decisions, package structure, and extension points. Target audience: developers who want to understand how Synaxis works internally or extend it. Documents to Create: docs/architecture/README.md (overview), docs/architecture/packages.md (package dependency graph), docs/architecture/mediator.md (CQRS with Mediator), docs/architecture/transports.md (how transports work), docs/architecture/providers.md (provider system), docs/architecture/adr-index.md (all ADRs with summaries). Content Requirements: Clear explanations of design decisions, Diagrams (architecture, flow, sequence), Code examples showing internal mechanisms, Extension points (how to add custom provider, custom transport), Performance considerations. Visual Diagrams: Package dependency graph (showing 4 tiers), Request flow diagram (HTTP -\u003e Executor -\u003e Handler -\u003e Provider), Provider selection flow, Pipeline behavior chain. Writing Style: Technical depth appropriate for senior developers, Clear headings and sections, Cross-references between documents. Estimated effort: 6-8 hours. Dependencies: All epics complete.","status":"open","priority":3,"issue_type":"task","owner":"rudimar@outlook.com","created_at":"2026-02-08T14:31:00.109253942+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T14:31:00.109253942+01:00","dependencies":[{"issue_id":"Synaxis-wfk","depends_on_id":"Synaxis-pdb","type":"blocks","created_at":"2026-02-08T14:31:18.928701143+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-wfk","depends_on_id":"Synaxis-4gd","type":"blocks","created_at":"2026-02-08T14:33:13.52617906+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-wfk","depends_on_id":"Synaxis-yeo","type":"blocks","created_at":"2026-02-08T14:33:13.58320689+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-wfk","depends_on_id":"Synaxis-a1r","type":"blocks","created_at":"2026-02-08T14:33:13.630830231+01:00","created_by":"Rudimar Ronsoni"},{"issue_id":"Synaxis-wfk","depends_on_id":"Synaxis-33p","type":"blocks","created_at":"2026-02-08T14:33:13.676941208+01:00","created_by":"Rudimar Ronsoni"}]}
{"id":"Synaxis-yeo","title":"SDK Core Implementation - Commands, Handlers, Behaviors, and Provider Packages","description":"Builds the core implementation layer on top of Foundation. Creates the Synaxis package containing command implementations, Mediator handlers, pipeline behaviors, and execution implementations. Also creates all provider packages (Synaxis.Providers.*) as separate NuGet packages. This is the engine that powers all transports and adapters. Scope: (1) Synaxis project with Commands/ (concrete command records implementing contract interfaces), Handlers/ (Mediator request handlers containing business logic), Behaviors/ (cross-cutting concerns via Mediator pipelines), Execution/ (ICommandExecutor and IStreamExecutor implementations using Mediator), Routing/ (provider selection logic). (2) Synaxis.Providers.OpenAI - HTTP client for OpenAI API, implements IChatProvider, IEmbeddingProvider, etc. (3) Synaxis.Providers.Azure - Azure OpenAI Service integration. (4) Synaxis.Providers.Anthropic - Claude API integration. (5) Synaxis.Providers.Google - Gemini API integration. (6) Additional providers as needed. Key Implementation Pattern: Commands are records implementing contract interfaces (e.g., ChatCommand implements IChatCommand), Handlers implement Mediator's IRequestHandler{T, TResponse}, Behaviors implement IPipelineBehavior{TMessage, TResponse} for cross-cutting concerns (logging, validation, metrics, auth, transactions), Executor implementations delegate to Mediator's Send and CreateStream methods. Pipeline Behaviors: LoggingBehavior (structured logging with correlation IDs), ValidationBehavior (input validation using FluentValidation or similar), MetricsBehavior (Prometheus metrics collection), AuthorizationBehavior (RBAC checks), TransactionBehavior (database transaction wrapping). Dependencies: Epic 1 (Foundation) must be complete with Abstractions and Contracts packages available. Success Criteria: Synaxis package builds with zero warnings, all handlers have unit tests with \u003e80% coverage, at least 3 provider packages created and tested (OpenAI, Azure, Anthropic), pipeline behaviors chain correctly, ICommandExecutor and IStreamExecutor functional, zero coupling between handlers (each is independent). Risks: Handler complexity grows quickly (mitigation: keep handlers focused, extract helpers), Provider APIs change (mitigation: version provider packages independently), Performance issues with Mediator (mitigation: source generators make it fast, benchmark if needed).","status":"closed","priority":1,"issue_type":"epic","owner":"rudimar@outlook.com","created_at":"2026-02-08T13:04:32.714585849+01:00","created_by":"Rudimar Ronsoni","updated_at":"2026-02-08T15:17:36.447433627+01:00","closed_at":"2026-02-08T15:17:36.447433627+01:00","close_reason":"Epic 2 complete: Synaxis Core implementation with Mediator integration, 3 provider packages (OpenAI, Azure, Anthropic), and 99 unit tests all building with zero warnings."}
