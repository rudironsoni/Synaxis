using System;
using System.Linq;
using System.Threading.Tasks;
using Xunit;
using Synaxis.Tests.Integration.Fixtures;
using Synaxis.Core.Models;
using Microsoft.EntityFrameworkCore;

namespace Synaxis.Tests.Integration;

/// <summary>
/// Integration tests for billing and cost calculation.
/// Tests usage tracking, budget enforcement, and credit charging.
/// </summary>
public class BillingCalculationTests : IClassFixture<SynaxisTestFixture>
{
    private readonly SynaxisTestFixture _fixture;

    public BillingCalculationTests(SynaxisTestFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public async Task ApiKey_TrackSpending_UpdatesCurrentSpend()
    {
        // Arrange
        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 100.00m,
            currentSpend: 0.00m);

        // Act - Simulate 10 requests at $0.01 each
        for (int i = 0; i < 10; i++)
        {
            apiKey.CurrentSpend += 0.01m;
        }

        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.NotNull(updatedKey);
        Assert.Equal(0.10m, updatedKey.CurrentSpend);
        Assert.Equal(99.90m, updatedKey.RemainingBudget);
        Assert.False(updatedKey.IsOverBudget);
    }

    [Fact]
    public async Task ApiKey_ExceedsBudget_MarkedAsOverBudget()
    {
        // Arrange
        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 10.00m,
            currentSpend: 9.50m);

        // Act - Add spending that exceeds budget
        apiKey.CurrentSpend += 0.60m;
        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.NotNull(updatedKey);
        Assert.Equal(10.10m, updatedKey.CurrentSpend);
        Assert.True(updatedKey.IsOverBudget);
        Assert.Equal(-0.10m, updatedKey.RemainingBudget);
    }

    [Fact]
    public async Task Organization_CreditBalance_DecreasesWithOverage()
    {
        // Arrange
        var organization = _fixture.TestOrganization;
        var initialBalance = organization.CreditBalance;

        // Act - Charge $5.00 from credits
        organization.CreditBalance -= 5.00m;
        _fixture.DbContext.Organizations.Update(organization);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedOrg = await _fixture.DbContext.Organizations.FindAsync(organization.Id);
        Assert.NotNull(updatedOrg);
        Assert.Equal(initialBalance - 5.00m, updatedOrg.CreditBalance);
    }

    [Fact]
    public async Task Organization_InsufficientCredits_CannotCharge()
    {
        // Arrange
        var organization = _fixture.TestOrganization;
        organization.CreditBalance = 1.00m;
        _fixture.DbContext.Organizations.Update(organization);
        await _fixture.DbContext.SaveChangesAsync();

        var chargeAmount = 5.00m;

        // Assert
        Assert.True(chargeAmount > organization.CreditBalance);
        
        // In real implementation, this would block the request or require payment
    }

    [Theory]
    [InlineData(100, 0.001, 0.10)]    // 100 requests at $0.001 each = $0.10
    [InlineData(1000, 0.002, 2.00)]   // 1000 requests at $0.002 each = $2.00
    [InlineData(50, 0.05, 2.50)]      // 50 requests at $0.05 each = $2.50
    public async Task CalculateRequestCost_VariousVolumes_CalculatesCorrectly(
        int requestCount,
        decimal costPerRequest,
        decimal expectedTotal)
    {
        // Arrange
        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 100.00m,
            currentSpend: 0.00m);

        // Act - Simulate requests
        for (int i = 0; i < requestCount; i++)
        {
            apiKey.CurrentSpend += costPerRequest;
        }

        // Assert
        Assert.Equal(expectedTotal, apiKey.CurrentSpend);
        Assert.True(apiKey.RemainingBudget >= 0);
    }

    [Fact]
    public async Task CalculateTokenCost_GPT4_CalculatesCorrectly()
    {
        // Arrange - GPT-4 pricing: $0.03/1K input tokens, $0.06/1K output tokens
        var inputTokens = 1000;
        var outputTokens = 500;

        var inputCost = (inputTokens / 1000m) * 0.03m;   // $0.03
        var outputCost = (outputTokens / 1000m) * 0.06m;  // $0.03
        var totalCost = inputCost + outputCost;           // $0.06

        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 10.00m,
            currentSpend: 0.00m);

        // Act
        apiKey.CurrentSpend += totalCost;
        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.NotNull(updatedKey);
        Assert.Equal(0.06m, updatedKey.CurrentSpend);
        Assert.Equal(9.94m, updatedKey.RemainingBudget);
    }

    [Fact]
    public async Task CalculateTokenCost_GPT35Turbo_CalculatesCorrectly()
    {
        // Arrange - GPT-3.5 pricing: $0.0015/1K input tokens, $0.002/1K output tokens
        var inputTokens = 2000;
        var outputTokens = 1000;

        var inputCost = (inputTokens / 1000m) * 0.0015m;   // $0.003
        var outputCost = (outputTokens / 1000m) * 0.002m;  // $0.002
        var totalCost = inputCost + outputCost;             // $0.005

        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 10.00m,
            currentSpend: 0.00m);

        // Act
        apiKey.CurrentSpend += totalCost;
        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.NotNull(updatedKey);
        Assert.Equal(0.005m, updatedKey.CurrentSpend);
    }

    [Fact]
    public async Task BudgetAlert_Threshold80Percent_TriggersAlert()
    {
        // Arrange
        var team = _fixture.TestTeam;
        var monthlyBudget = team.MonthlyBudget!.Value;
        var alertThreshold = team.BudgetAlertThreshold;
        var alertAmount = monthlyBudget * (alertThreshold / 100m);

        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: monthlyBudget,
            currentSpend: 0.00m);

        // Act - Spend up to alert threshold
        apiKey.CurrentSpend = alertAmount;
        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.NotNull(updatedKey);
        Assert.True(updatedKey.CurrentSpend >= alertAmount);
        
        // In real implementation, this would trigger an alert notification
        var percentageUsed = (updatedKey.CurrentSpend / monthlyBudget) * 100m;
        Assert.True(percentageUsed >= alertThreshold);
    }

    [Fact]
    public async Task MonthlyReset_NewMonth_ResetsSpending()
    {
        // Arrange
        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 100.00m,
            currentSpend: 75.00m);

        // Act - Simulate monthly reset
        apiKey.CurrentSpend = 0.00m;
        apiKey.UpdatedAt = DateTime.UtcNow;
        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.NotNull(updatedKey);
        Assert.Equal(0.00m, updatedKey.CurrentSpend);
        Assert.Equal(100.00m, updatedKey.RemainingBudget);
        Assert.False(updatedKey.IsOverBudget);
    }

    [Fact]
    public async Task MultiCurrency_Billing_ConvertsCorrectly()
    {
        // Arrange
        var organization = _fixture.TestOrganization;
        organization.BillingCurrency = "EUR";
        organization.CreditBalance = 100.00m;
        organization.CreditCurrency = "EUR";

        // Assume USD to EUR rate: 1 USD = 0.92 EUR
        var usdAmount = 10.00m;
        var eurAmount = usdAmount * 0.92m;

        // Act
        organization.CreditBalance -= eurAmount;
        _fixture.DbContext.Organizations.Update(organization);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedOrg = await _fixture.DbContext.Organizations.FindAsync(organization.Id);
        Assert.NotNull(updatedOrg);
        Assert.Equal(100.00m - eurAmount, updatedOrg.CreditBalance);
        Assert.Equal("EUR", updatedOrg.BillingCurrency);
    }

    [Fact]
    public async Task TeamBudget_AggregatesAllKeys_CalculatesTotalSpend()
    {
        // Arrange - Create multiple keys for the same team
        var key1 = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 50.00m,
            currentSpend: 10.00m);
        
        var key2 = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 50.00m,
            currentSpend: 15.00m);
        
        var key3 = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 50.00m,
            currentSpend: 20.00m);

        // Act - Calculate total team spend
        var teamKeys = await _fixture.DbContext.VirtualKeys
            .Where(k => k.TeamId == _fixture.TestTeam.Id)
            .ToListAsync();

        var totalSpend = teamKeys.Sum(k => k.CurrentSpend);

        // Assert
        Assert.True(totalSpend >= 45.00m); // At least the 3 keys we just created
        
        var teamBudget = _fixture.TestTeam.MonthlyBudget!.Value;
        var percentageUsed = (totalSpend / teamBudget) * 100m;
        
        // Check if approaching budget alert threshold
        if (percentageUsed >= _fixture.TestTeam.BudgetAlertThreshold)
        {
            // Would trigger alert in real implementation
            Assert.True(true, "Budget alert threshold reached");
        }
    }

    [Theory]
    [InlineData("free", 0, 0, 100000)]           // Free tier limits
    [InlineData("pro", 100, 1000000, 10000000)]  // Pro tier limits
    [InlineData("enterprise", 1000, -1, -1)]     // Enterprise unlimited
    public void TierLimits_DifferentTiers_HasCorrectLimits(
        string tier,
        int expectedConcurrent,
        long expectedMonthlyRequests,
        long expectedMonthlyTokens)
    {
        // Arrange
        var organization = new Organization
        {
            Id = Guid.NewGuid(),
            Name = $"Test Org {tier}",
            Slug = $"test-{tier}",
            Tier = tier,
            PrimaryRegion = "us-east-1",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        // Act - Set limits based on tier
        switch (tier)
        {
            case "free":
                organization.MaxConcurrentRequests = 0;
                organization.MonthlyRequestLimit = 100000;
                organization.MonthlyTokenLimit = 100000;
                break;
            case "pro":
                organization.MaxConcurrentRequests = 100;
                organization.MonthlyRequestLimit = 1000000;
                organization.MonthlyTokenLimit = 10000000;
                break;
            case "enterprise":
                organization.MaxConcurrentRequests = 1000;
                organization.MonthlyRequestLimit = null; // Unlimited
                organization.MonthlyTokenLimit = null;   // Unlimited
                break;
        }

        // Assert
        Assert.Equal(tier, organization.Tier);
        Assert.Equal(expectedConcurrent, organization.MaxConcurrentRequests);
        
        if (expectedMonthlyRequests == -1)
        {
            Assert.Null(organization.MonthlyRequestLimit);
        }
        else
        {
            Assert.Equal(expectedMonthlyRequests, organization.MonthlyRequestLimit);
        }
    }

    [Fact]
    public async Task BillingCurrency_EURBilling_ConvertsFromUSD()
    {
        // Arrange
        var organization = _fixture.TestOrganization;
        organization.BillingCurrency = "EUR";
        
        var usdAmount = 100.00m;
        var exchangeRate = 0.92m; // 1 USD = 0.92 EUR
        var eurAmount = usdAmount * exchangeRate;

        // Act
        var convertedAmount = eurAmount;

        // Assert
        Assert.Equal(92.00m, convertedAmount);
        Assert.Equal("EUR", organization.BillingCurrency);
    }

    [Fact]
    public async Task BillingCurrency_BRLBilling_ConvertsFromUSD()
    {
        // Arrange
        var organization = _fixture.TestOrganization;
        organization.BillingCurrency = "BRL";
        
        var usdAmount = 100.00m;
        var exchangeRate = 5.00m; // 1 USD = 5.00 BRL
        var brlAmount = usdAmount * exchangeRate;

        // Act
        var convertedAmount = brlAmount;

        // Assert
        Assert.Equal(500.00m, convertedAmount);
        Assert.Equal("BRL", organization.BillingCurrency);
    }

    [Fact]
    public async Task InvoiceGeneration_MonthlyPeriod_IncludesAllCharges()
    {
        // Arrange
        var periodStart = new DateTime(2024, 1, 1);
        var periodEnd = new DateTime(2024, 1, 31);

        var charges = new[]
        {
            new { Date = new DateTime(2024, 1, 5), Amount = 10.00m, Description = "API Usage" },
            new { Date = new DateTime(2024, 1, 15), Amount = 25.00m, Description = "API Usage" },
            new { Date = new DateTime(2024, 1, 25), Amount = 15.00m, Description = "API Usage" }
        };

        // Act
        var totalAmount = charges.Sum(c => c.Amount);

        // Assert
        Assert.Equal(50.00m, totalAmount);
        Assert.Equal(3, charges.Length);
    }

    [Fact]
    public async Task CreditTransaction_TopUp_IncreasesBalance()
    {
        // Arrange
        var organization = _fixture.TestOrganization;
        var initialBalance = organization.CreditBalance;
        var topUpAmount = 100.00m;

        // Act
        organization.CreditBalance += topUpAmount;
        _fixture.DbContext.Organizations.Update(organization);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedOrg = await _fixture.DbContext.Organizations.FindAsync(organization.Id);
        Assert.Equal(initialBalance + topUpAmount, updatedOrg.CreditBalance);
    }

    [Fact]
    public async Task SpendLog_TracksModelUsage_ByProvider()
    {
        // Arrange
        var spendLogs = new[]
        {
            new { Model = "gpt-4", Provider = "openai", Cost = 10.00m },
            new { Model = "claude-2", Provider = "anthropic", Cost = 8.00m },
            new { Model = "gpt-3.5-turbo", Provider = "openai", Cost = 2.00m }
        };

        // Act
        var openaiSpend = spendLogs.Where(s => s.Provider == "openai").Sum(s => s.Cost);
        var anthropicSpend = spendLogs.Where(s => s.Provider == "anthropic").Sum(s => s.Cost);

        // Assert
        Assert.Equal(12.00m, openaiSpend);
        Assert.Equal(8.00m, anthropicSpend);
    }

    [Fact]
    public async Task ModelPricing_GPT4Turbo_CalculatesCorrectly()
    {
        // Arrange - GPT-4 Turbo pricing: $0.01/1K input, $0.03/1K output
        var inputTokens = 5000;
        var outputTokens = 2000;

        var inputCost = (inputTokens / 1000m) * 0.01m;   // $0.05
        var outputCost = (outputTokens / 1000m) * 0.03m;  // $0.06
        var totalCost = inputCost + outputCost;           // $0.11

        // Assert
        Assert.Equal(0.11m, totalCost);
    }

    [Fact]
    public async Task ModelPricing_Claude3_CalculatesCorrectly()
    {
        // Arrange - Claude 3 pricing: $0.015/1K input, $0.075/1K output
        var inputTokens = 2000;
        var outputTokens = 1000;

        var inputCost = (inputTokens / 1000m) * 0.015m;   // $0.03
        var outputCost = (outputTokens / 1000m) * 0.075m;  // $0.075
        var totalCost = inputCost + outputCost;            // $0.105

        // Assert
        Assert.Equal(0.105m, totalCost);
    }

    [Fact]
    public async Task BudgetAlert_MultipleThresholds_TriggersCorrectly()
    {
        // Arrange
        var monthlyBudget = 1000.00m;
        var thresholds = new[] { 50m, 80m, 90m, 100m }; // Percentages

        // Act
        var currentSpend = 850.00m; // 85% of budget
        var percentageUsed = (currentSpend / monthlyBudget) * 100m;

        // Assert
        Assert.True(percentageUsed >= 80m); // Should trigger 80% alert
        Assert.False(percentageUsed >= 90m); // Should not trigger 90% alert yet
    }

    [Fact]
    public async Task OverageFees_ExceedsBudget_ChargesOverageRate()
    {
        // Arrange
        var apiKey = await _fixture.CreateApiKeyWithQuotaAsync(
            maxBudget: 100.00m,
            currentSpend: 100.00m);

        var overageAmount = 10.00m;
        var overageRate = 1.5m; // 1.5x regular rate
        var overageCost = overageAmount * overageRate;

        // Act
        apiKey.CurrentSpend += overageCost;
        _fixture.DbContext.VirtualKeys.Update(apiKey);
        await _fixture.DbContext.SaveChangesAsync();

        // Assert
        var updatedKey = await _fixture.DbContext.VirtualKeys.FindAsync(apiKey.Id);
        Assert.Equal(115.00m, updatedKey.CurrentSpend);
        Assert.True(updatedKey.IsOverBudget);
    }

    [Fact]
    public async Task Discounts_VolumeDiscount_AppliesCorrectly()
    {
        // Arrange
        var basePrice = 1000.00m;
        var volumeDiscount = 0.10m; // 10% discount for high volume

        // Act
        var discountedPrice = basePrice * (1 - volumeDiscount);

        // Assert
        Assert.Equal(900.00m, discountedPrice);
    }

    [Fact]
    public async Task Proration_UpgradeMidMonth_CalculatesProration()
    {
        // Arrange
        var monthlyPrice = 100.00m;
        var daysInMonth = 30;
        var daysRemaining = 15;
        
        // Act
        var proratedAmount = (monthlyPrice / daysInMonth) * daysRemaining;

        // Assert
        Assert.Equal(50.00m, proratedAmount);
    }

    [Fact]
    public async Task TaxCalculation_EUVATRate_AppliesTax()
    {
        // Arrange
        var subtotal = 100.00m;
        var vatRate = 0.20m; // 20% VAT
        
        // Act
        var taxAmount = subtotal * vatRate;
        var total = subtotal + taxAmount;

        // Assert
        Assert.Equal(20.00m, taxAmount);
        Assert.Equal(120.00m, total);
    }

    [Fact]
    public async Task CreditExpiration_ExpiredCredits_MarkedAsExpired()
    {
        // Arrange
        var creditTransaction = new CreditTransaction
        {
            Id = Guid.NewGuid(),
            OrganizationId = _fixture.TestOrganization.Id,
            Amount = 50.00m,
            Type = "purchase",
            ExpiresAt = DateTime.UtcNow.AddDays(-1), // Expired yesterday
            CreatedAt = DateTime.UtcNow.AddMonths(-6)
        };

        // Assert
        Assert.True(creditTransaction.ExpiresAt < DateTime.UtcNow);
    }

    [Fact]
    public async Task UsageAnalytics_ByRegion_AggregatesCorrectly()
    {
        // Arrange
        var usageByRegion = new Dictionary<string, decimal>
        {
            { "eu-west-1", 100.00m },
            { "us-east-1", 150.00m },
            { "sa-east-1", 50.00m }
        };

        // Act
        var totalUsage = usageByRegion.Values.Sum();

        // Assert
        Assert.Equal(300.00m, totalUsage);
        Assert.Equal(3, usageByRegion.Count);
    }

    [Fact]
    public async Task UsageAnalytics_ByTeam_CalculatesTeamCosts()
    {
        // Arrange
        var teamSpending = new[]
        {
            new { TeamId = Guid.NewGuid(), TeamName = "Engineering", Spend = 500.00m },
            new { TeamId = Guid.NewGuid(), TeamName = "Data Science", Spend = 750.00m },
            new { TeamId = Guid.NewGuid(), TeamName = "Product", Spend = 250.00m }
        };

        // Act
        var totalSpending = teamSpending.Sum(t => t.Spend);
        var highestSpender = teamSpending.OrderByDescending(t => t.Spend).First();

        // Assert
        Assert.Equal(1500.00m, totalSpending);
        Assert.Equal("Data Science", highestSpender.TeamName);
    }
}
