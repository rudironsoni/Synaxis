meta {
  name: Requests-Minute-Sliding-Throttle-100%
  type: http
  seq: 8
}

post {
  url: {{baseUrl}}/api/v1/inference/chat/completions
  body: json
  auth: bearer
}

auth:bearer {
  token: {{apiKey}}
}

headers {
  Content-Type: application/json
  X-Organization-Id: {{orgId}}
  X-Test-Quota-Type: requests
  X-Test-Quota-Limit: 100
  X-Test-Quota-Window: minute
  X-Test-Quota-Window-Type: sliding
  X-Test-Quota-Action: throttle
  X-Test-Simulate-Usage: 100
}

body:json {
  {
    "model": "openai/gpt-4",
    "messages": [
      {
        "role": "user",
        "content": "Test request - 100% sliding window (throttle)"
      }
    ],
    "max_tokens": 10
  }
}

assert {
  res.status: eq 429
  res.headers.x-ratelimit-limit: eq 100
  res.headers.x-ratelimit-remaining: eq 0
  res.headers.x-ratelimit-window-type: eq sliding
  res.headers.retry-after: isDefined
}

tests {
  test("Request throttled in sliding window", function() {
    expect(res.status).to.equal(429);
  });
  
  test("Sliding window limit reached", function() {
    expect(res.headers['x-ratelimit-window-type']).to.equal('sliding');
    expect(res.headers['x-ratelimit-limit']).to.equal('100');
    expect(parseInt(res.headers['x-ratelimit-remaining'])).to.equal(0);
  });
  
  test("Retry-After based on oldest request", function() {
    // In sliding window, retry after = time until oldest request expires
    const retryAfter = parseInt(res.headers['retry-after']);
    expect(retryAfter).to.be.a('number');
    expect(retryAfter).to.be.greaterThan(0);
    expect(retryAfter).to.be.lessThanOrEqual(60);
  });
  
  test("Reset shows when capacity available", function() {
    const reset = parseInt(res.headers['x-ratelimit-reset']);
    const retryAfter = parseInt(res.headers['retry-after']);
    const now = Math.floor(Date.now() / 1000);
    
    // Reset should be approximately now + retry-after
    expect(Math.abs(reset - (now + retryAfter))).to.be.lessThan(2);
  });
  
  test("Error indicates sliding window", function() {
    expect(res.body.error.code).to.equal('rate_limit_exceeded');
    expect(res.body.error.details.window_type).to.equal('sliding');
    expect(res.body.error.message).to.match(/sliding window|last 60 seconds/i);
  });
}

docs {
  # Requests-Minute-Sliding-Throttle-100%
  
  Tests throttling with sliding window at 100% usage.
  
  ## Test Configuration
  - Metric Type: requests
  - Time Granularity: minute
  - Window Type: sliding
  - Action: throttle
  - Usage Level: 100% (100 requests in last 60 seconds)
  
  ## Sliding Window Throttle
  - Counts all requests in last 60 seconds
  - Retry-After = time until oldest request expires
  - More predictable recovery than fixed windows
  
  ## Example
  ```
  14:03:00 - Request 1 (oldest in window)
  14:03:01-14:03:59 - Requests 2-100
  14:04:00 - Request 101 → Throttled
  14:04:00 - Retry-After: 1s (wait for request 1 to expire)
  14:04:01 - Request 1 expires, capacity available
  ```
  
  ## Client Behavior
  1. Read Retry-After header
  2. Wait specified time (precise in sliding windows)
  3. Request will succeed after wait
  4. One slot opens as each request expires
  
  ## Advantages over Fixed Window
  ✅ No sudden burst after window reset
  ✅ Gradual capacity recovery
  ✅ More predictable behavior
  ✅ Better traffic shaping
}
